import json, re, os
import gpt_interaction

output_folder = "rq1_results" 
def read_code(file_path):
    '''
    Arguments:
    - `file_path` (str): Path to the code file.

    Function:
    Reads and returns the content of a file as a string.
    '''
    with open(file_path, 'r', encoding='utf-8') as file:
        code = file.read()
    return code

def extract_symbols(code):
    '''
    Arguments:
    - `code` (str): Source code to extract symbols from.

    Function:
    Extracts and returns a list of symbols ('>' and '!') from the code.
    '''
    lines = code.split('\n')
    symbols = [re.match(r'^\s*([>!]+)', line).group(1) for line in lines if re.match(r'^\s*([>!]+)', line)]
    return symbols

def remove_comments_and_blank_lines(code):
    '''
    Arguments:
    - `code` (str): Source code to clean.

    Function:
    Removes comments, blank lines, and lines with only symbols from the code.
    '''
    code = re.sub(r'#.*', '', code)
    code = re.sub(r"'''(.*?)'''", '', code, flags=re.DOTALL)
    code = re.sub(r'"""(.*?)"""', '', code, flags=re.DOTALL)
    lines = code.split('\n')
    clean_lines = [line for line in lines if line.strip() != '' and not re.match(r'^\s*[>!]+\s*$', line)]
    code = '\n'.join(clean_lines)
    return code

def add_updated_code(existing_text, covered_code):
    '''
    Arguments:
    - `existing_text` (str): Existing text to prepend.
    - `covered_code` (str): Updated code to append.

    Function:
    Appends the updated code to the existing text and returns the combined string.
    '''
    updated_code_prompt = f'{existing_text}\nJAVA PROGRAM:\n{covered_code}\n'
    return updated_code_prompt

def insert_code_and_testcase_in_prompt(existing_text, initial_code, test_case):
    '''
    Arguments:
    - `existing_text` (str): Existing prompt text.
    - `initial_code` (str): Initial code to insert.
    - `test_case` (str): Test case to insert.

    Function:
    Inserts test case and initial code into the prompt text and returns it.
    '''
    prompt_with_code_and_testcase = f'{existing_text}\n{test_case}\nJAVA PROGRAM:\n{initial_code}'
    return prompt_with_code_and_testcase

def check_test_cases_generated(response):
    '''
    Arguments:
    - `response` (str): Response text to check.

    Function:
    Checks if test cases are generated by looking for specific keywords in the response.
    '''
    return "test case" in response.lower()

def check_all_coverage_symbols(new_coverage, old_coverage):
    '''
    Arguments:
    - `new_coverage` (list): List of new coverage symbols.
    - `old_coverage` (list): List of old coverage symbols.

    Function:
    Checks if all coverage symbols are covered in the new coverage list.
    '''
    min_length = min(len(new_coverage), len(old_coverage))
    for i in range(min_length):
        new_symbol = new_coverage[i]
        old_symbol = old_coverage[i]
        if new_symbol == '!' and old_symbol == '!':
            return False #coverage increasing prompt
        elif new_symbol == '>' and old_symbol == '!':
            return True #exception raising prompt
    return all(s == '>' for s in old_coverage)

def prepend_exclamation_mark(code):
    '''
    Arguments:
    - `code` (str): Source code to modify.

    Function:
    Prepends '!' to each line of the code and returns the modified code.
    '''
    lines = code.split('\n')
    modified_lines = ["!" + line for line in lines]
    modified_code = '\n'.join(modified_lines)
    return modified_code

def add_coverage_symbols_to_code(clean_altered_code, coverage_symbols):
    '''
    Arguments:
    - `clean_altered_code` (str): Cleaned code to update.
    - `coverage_symbols` (list): List of coverage symbols to add.

    Function:
    Adds coverage symbols to the cleaned code and returns the updated code.
    '''
    lines = clean_altered_code.split('\n')
    result_code = []
    for line, symbol in zip(lines, coverage_symbols):
        if re.match(r'^\s*([^\s])', line):  # Check if the line is not empty or only spaces
            result_line = symbol+ ' ' + line.lstrip()
            result_code.append(result_line)
        else:
            result_code.append(line)  # Append empty lines or lines with only spaces
    return '\n'.join(result_code)

def remove_duplicates(raw_input, generated_test_seeds):
    '''
    Arguments:
    - `raw_input` (list): List of test seeds to filter.
    - `generated_test_seeds` (str): String of previously generated test seeds.

    Function:
    Removes duplicates from the raw input based on the generated test seeds and returns a sorted list.
    '''
    unique_input = []
    for item in raw_input:
        if f'{item}\n' not in generated_test_seeds:
            unique_input.append(item)
    unique_input.sort()  # Sort to maintain order
    return unique_input


def extract_initial_code(submission_id, json_data):
    '''
    Arguments:
    - `submission_id` (str): Submission identifier.
    - `json_data` (list): List of submission data.

    Function:
    Extracts and returns the initial code tokens for a given submission.
    '''
    for submission in json_data:
        if submission['submission_id'] == submission_id:
            return submission['code_tokens']
    return None

def extract_initial_code_for_execution(submission_id, json_data):
    '''
    Arguments:
    - `submission_id` (str): Submission identifier.
    - `json_data` (list): List of submission data.

    Function:
    Extracts and returns the initial code tokens for execution for a given submission.
    '''
    for submission in json_data:
        if submission['submission_id'] == submission_id:
            return submission['code_tokens']
    return None

def create_json_file(submission_id):
    '''
    Arguments:
    - `submission_id` (str): Submission identifier.

    Function:
    Creates a JSON file for the submission with an empty cycles list and returns the file path.
    '''
    json_filename = f"{submission_id}.json"
    json_filepath = os.path.join(output_folder, json_filename)
    with open(json_filepath, 'w', encoding='utf-8') as json_file:
        json.dump({'submission_id': submission_id, 'cycles': []}, json_file, indent=2)
    return json_filepath

def save_cycle_response(json_filepath, response):
    '''
    Arguments:
    - `json_filepath` (str): Path to the JSON file.
    - `response` (dict): Cycle response data.

    Function:
    Appends a cycle response to the JSON file.
    '''
    with open(json_filepath, 'r', encoding='utf-8') as json_file:
        data = json.load(json_file)
        data['cycles'].append(response)
    with open(json_filepath, 'w', encoding='utf-8') as json_file:
        json.dump(data, json_file, indent=2)

def save_java_execution_output(submission_id, output):
    '''
    Arguments:
    - `submission_id` (str): Submission identifier.
    - `output` (str): Execution output to save.

    Function:
    Saves the execution output to a file named with the submission identifier.
    '''
    output_filepath = f"results/{submission_id}_output.txt"
    with open(output_filepath, 'w', encoding='utf-8') as output_file:
        output_file.write(output)

