[
    {},
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02469",
        "code_tokens": "import sys\nimport math\nfrom functools import reduce\ndef gcd(x, y):\n    if x < y:\n        x, y = y, x\n    while y > 0:\n        r = x % y\n        x = y\n        y = r\n    return x\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\ndef solve(_n_list):\n    return reduce(lcm, _n_list)\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    cnt = int(_input[0])\n    n_list = tuple(map(int, _input[1].split()))\n    print(solve(n_list))",
        "submission_id": "s871541992",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 20
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p01869",
        "code_tokens": "import bisect\na=[]\ndef f(a,bin,n):\n    if bin>n:return\n    if bin:a+=[bin]\n    f(a,bin*10+2,n)\n    f(a,bin*10+8,n)\ndef g(n,p):\n    m=-1<<20\n    x=bisect.bisect_left(a,n)\n    if x!=len(a) and a[x]==n:m=1\n    if a[p]**2>n:return m\n    if n%a[p]==0:m=g(n//a[p],p)+1\n    return max(m,g(n,p+1))\nn=int(input())\nif n&1:print(-1);exit()\nf(a,0,n)\na=sorted(a)+[10**20]\nb=g(n,0)\nif b<0:b=-1\nprint(b)",
        "submission_id": "s307987195",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 21
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02406",
        "code_tokens": "n=int(input())\na,c,i=[],0,1\nwhile i <= n:\n    if c==0:\n        x=i\n        if x%3==0:\n            print(' '+i, end='')\n            i+=1\n            continue\n    c=0\n    if x%10==3:\n        print(' '+i, end='')\n        i+=1\n        continue\n    x//=10\n    if x == 0:\n        i+=1\n        continue\n    else:\n        c=1\nprint()",
        "submission_id": "s547062735",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 21
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02819",
        "code_tokens": "def is_prime(n, k=100):\n    n = abs(n)\n    if n == 2:\n        return True\n    if n < 2 or n&1 == 0:\n        return False\n    for i in xrange(3, k):\n        x, y = n, i\n        while y:\n            x, y = y, x%y\n        if x != 1:\n            continue\n        if pow(2, n-1, n) != 1:\n            return False\n    return True\nX = int(input())\nwhile True:\n    if is_prime(X):\n        print(X)\n        break\n    X += 1",
        "submission_id": "s592816350",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 21
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03377",
        "code_tokens": "mport sys\nimport copy\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [A, B, X] = [int(input_raw[0]), int(input_raw[1]), int(input_raw[2])]\n    if A + B >= X and A <= X:\n        print 'YES'\n    else:\n        print 'NO'\nif __name__ == '__main__':\n    main()",
        "submission_id": "s587008480",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 21
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03241",
        "code_tokens": "import math\nn,m = map(int, input().split())\nk = int(math.sqrt(m))\na = []\nb = []\nfor i in range(1,k+10):\n    if m%i==0:\n        a.append(m//i)\n        b.append(i)\n    else:\n        continue\nfor i in a:\n    if m//i>=n:\n        ans = i\n        break\nfor i in reversed(b):\n    if m//i>=n:\n        ans = max(ans,i)\n        break\n    else:\n        continue\nprint(ans)",
        "submission_id": "s164873666",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 22
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02600",
        "code_tokens": "def laod_to_mill():\n    days = int(input())\n    prices = tuple(map(int, input().split()))\n    if max(prices) == prices[0]:\n        print(1000)\n        return\n    total = 1000\n    ks = 0\n    for d in range(days):\n        if d == days - 1:\n            total += ks * prices[d]\n            break\n        if prices[d] < prices[d + 1]:\n            buy = total // prices[d]\n            total -= buy * prices[d]\n            ks += buy\n        elif prices[d] > prices[d + 1]:\n            total += ks * prices[d]\n            ks = 0\n    print(total)\ndef main():\n    laod_to_mill()\nif __name__ == '__main__':\n    main()",
        "submission_id": "s898387127",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 24
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p00168",
        "code_tokens": "from __future__ import division,print_function\ntry:\n    input = raw_input\nexcept NameError:\n    pass\nmemo=[0]*31\ndef solve(x):\n    if memo[x]==0:\n        if x>1:\n            memo[x]=solve(x-1)+solve(x-2)+solve(x-3)\n            return memo[x]\n        elif x==0:\n            memo[x]=1\n            return 1\n        else:\n            return 0\n    else:\n        return memo[x]\ndef main():\n    while True:\n        inp=input()\n        if inp==0:\n            break\n        print(solve(inp))\nmain()",
        "submission_id": "s538829562",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 25
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02834",
        "code_tokens": "N, U, V = map(int, input().split())\nA = [[] for _ in range(N)]\nimport sys\nsys.setrecursionlimit(10**8)\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    A[a - 1].append(b - 1)\n    A[b - 1].append(a - 1)\nC = [0] * N\ndef DFS(x, pre, cnt):\n    if C[x] < cnt:\n        C[x] = cnt\n    cnt += 1\n    for a in A[x]:\n        if a == pre:\n            continue\n        if a == (U - 1):\n            C[a] = cnt\n            continue:\n        DFS(a, x, cnt)\nDFS(V - 1, -1, 0)\nans = max(C) - 1\nif ans < 0:\n    ans = 0\nprint(ans)",
        "submission_id": "s312890776",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 25
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02825",
        "code_tokens": "n, m, v, p = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ndef check(x):\n    if x > n - p:\n        return True\n    for i in range(x + 1, n - p + 1):\n        if a[x] + m < a[i]:\n            return False\n    if v - x - p > 0:\n        cnt = 0\n        for i in range(x + 1, n - p + 1):\n            cnt += min((a[x] + m) - a[i], m)\n        if (cnt // (v - x - p)) >= m:\n            return True\n        else:\n            return False\n    else:\n        return True\nlb = -1  \nub = n - 1  \nwhile ub - lb > 1:\n    mid = (ub + lb) // 2\n    if check(mid):\n        ub = mid\n    else:\n        lb = mid\nans = n - ub\nprint(ans)",
        "submission_id": "s793394062",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 29
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02406",
        "code_tokens": "inData = int(input())\nseqData = list(range(1,inData+1,1))\noutData = [0] * inData\nfor thisData in seqData:\n    if thisData == inData:\n        if thisData%3 == 0 or thisData%10==3:\n            print(\" \"+str(thisData), end = \"\")\n        else:\n            for i in range(5):\n                i=i+1\n                over =  10 ** i\n                tmp = thisData/over\n                if int(tmp % 10) == 3:\n                    print(\" \"+str(thisData), end = \"\")\n                    break\n                else:\n                    print(\"\")\n    else:\n        if thisData%3 == 0 or thisData%10==3:\n            print(\" \"+str(thisData), end = \"\")\n        else:\n            for i in range(5):\n                i=i+1\n                over =  10 ** i\n                tmp = thisData/over\n                if int(tmp % 10) == 3:\n                    print(\" \"+str(thisData), end = \"\")\n                    break\n                else:\n                    pass:",
        "submission_id": "s612282126",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 30
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02834",
        "code_tokens": "from collections import deque\nN,u,v = map(int,input().split())\nE = [[] for _ in range(N + 1)]\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    E[a].append(b)\n    E[b].append(a)\nprint(E)\ndef bfs(start,N,AB):\n    d = [-1]*(N+1)\n    d[start] = 0\n    q = [start]\n    while q:\n        print(d,q)\n        v = q.pop()\n        cnt = d[v]+1\n        for i in E[v]:\n            if(d[i] == -1):\n                q.append(i)\n                d[i] = cnt\n    return d\ntaka = bfs(u,N,AB)\naoki = bfs(v,N,AB)\nprint(taka,aoki)\nfin = -1\nfor i in range(N+1):\n    if(taka[i] < aoki[i]):\n        fin = max(fin,aoki[i])\n        ans = fin - (aoki[i]-taka[i]+1)//2\nprint(ans)",
        "submission_id": "s839633992",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 30
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p00535",
        "code_tokens": "H, W = map(int, input().split())\nS = []\nfor i in range(H):\n    tmp = []\n    s = input()\n    for j in range(W):\n        if s[j] == '.':\n            tmp.append(-1)\n        else:\n            tmp.append(int(s[j]))\n    S.append(tmp)\nD = [0, 1, -1, -1, 0, -1, 1, 1, 0]\nupdate = 1; ans = 0\nwhile update:\n    update = 0; ans += 1\n    d = set()\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] > -1:\n                cnt = 0\n                for k in range(8):\n                    ni = i + D[k]; nj = j + D[k+1]\n                    if S[ni][nj] == -1:\n                        cnt += 1\n                if S[i][j] <= cnt:\n                    d.add((i, j))\n                    update = 1\n    for i, j in d:\n        S[i][j] = -1\nprint(ans-1)",
        "submission_id": "s786968461",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 30
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02469",
        "code_tokens": "import math\ndef sieve(n):\n    p = [1] * (n + 1)\n    p[0] = p[1] = 0\n    for i in range(math.ceil((n + 1) ** 0.5)):\n        if p[i]:\n            for j in range(2 * i, len(p), i):\n                p[j] = 0\n    return p\ndef prime_factor(n):\n    p = sieve(int(n ** 0.5))\n    factor = []\n    for pi in compress(count(0), p):\n        while n % pi == 0:\n            n //= pi\n            factor.append(pi)\n    if n != 1:\n        factor.append(n)\n    return factor\nfrom collections import Counter\nfrom sys import stdin\nreadline = stdin.readline\nn = int(readline())\nc =[Counter(prime_factor(ai)) for ai in map(int, readline().split())]\ns = set()\nfor ci in c:\n    s.update(ci.keys())\nret = 1\nfor i in [i ** max(ci[i] for ci in c) for i in s]:\n    ret *= i\nprint(ret)",
        "submission_id": "s913843751",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 31
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02600",
        "code_tokens": "import sys\nint1 = lambda x: int(x) - 1\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(500000)\nN = int(readline())\nXYP = [list(map(int, readline().split())) for _ in range(N)]\nx_cost = [0] * ((1 << N) * N)\ny_cost = [0] * ((1 << N) * N)\nfor bit in range(1 << N):\n    for i, (xi, yi, _) in enumerate(XYP):\n        x_cost[bit * N + i] = abs(xi)\n        y_cost[bit * N + i] = abs(yi)\n        for k, (xk, yk, _) in enumerate(XYP):\n            if bit & (1 << k):\n                x_cost[bit * N + i] = min(x_cost[bit * N + i], abs(xi - xk))\n                y_cost[bit * N + i] = min(y_cost[bit * N + i], abs(yi - yk))\nans = [sys.maxsize for _ in range(N + 1)]\nfor bit in range(1 << N):\n    cnt = bin(bit).count('1')\n    bit_ = bit\n    while bit_ >= 0:\n        bit_ &= bit\n        cost = 0\n        for k in range(N):\n            cost += 1 * XYP[k][2] * min(x_cost[bit_ * N + k],\n                                        y_cost[(bit - bit_) * N + k])\n        ans[cnt] = min(ans[cnt], cost)\n        bit_ -= 1\nfor i in range(N + 1):\n    print(ans[i])",
        "submission_id": "s824490865",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 32
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03241",
        "code_tokens": "N, M = map(int, input().split())\ndef factorize(n):\n    fct = []\n    b, e = 2, 0\n    while b * b <= n:\n        while n % b == 0:\n            n = n // b\n            e = e + 1\n        if e > 0:\n            fct.append((b, e))\n        b, e = b + 1, 0\n    if n > 1:\n        fct.append((n, 1))\n    return fct\ndef divisorize(fct):\n    b, e = fct.pop()\n    pre_div = divisorize(fct) if fct else [[]]\n    suf_div = [[(b, k)] for k in range(e + 1)]\n    return [pre + suf for pre in pre_div for suf in suf_div]\ndef num(fct):\n    a = 1\n    for base, exponent in fct:\n        a = a * base**exponent\n    return a\nfct = factorize(M)\nL   = []\nfor div in divisorize(fct):\n    L.append(num(div))\nL.sort()\nL.reverse()\nfor l in L:\n    if l * N <= M and M % l == 0:\n        print(l)\n        break",
        "submission_id": "s177967558",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 34
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03943",
        "code_tokens": "def cin():\n\treturn map(int,input().split())\ndef cino(test=False):\n    if not test:\n        return int(input())\n    else:\n        return input()\ndef cina():\n  return list(map(int,input().split()))\na,b,c  = cin()\np = -1\nq = 1e9\nr = -1\ns = 1e9\nfor i in range(c):\n  x,y,z = cin()\n  if z==1:\n    p = max(x,p)\n  elif z==2:\n    q = min(x,q)\n  elif z==3:\n    r = max(r,y)\n  else:\n    s = min(s,y)\nif p==-1:\n    p = 0\nif q==1e9:\n    q = a\nif r==-1:\n    r=0\nif s==1e9:\n    s=b\nans = (q-p)*(s-r)\nif ans>0:\n    print(ans)\nelse:\n    print(0)",
        "submission_id": "s993509670",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 37
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02344",
        "code_tokens": "import sys\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\ndef link(x,wx,y,wy,z,element):\n    z = z+wy-wx\n    element[x] = y\n    weight[x] = z\nn,q = map(int, input().split());\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')",
        "submission_id": "s053347677",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 39
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02819",
        "code_tokens": "import math\nfrom bisect import bisect_left\nfrom random import random\ndef eratosthenes(n):\n    prime = []\n    limit = math.sqrt(n)\n    data = [i + 1 for i in range(1, n)]\n    while True:\n        p = data[0]\n        if limit <= p:\n            return prime + data\n        prime.append(p)\n        data = [e for e in data if e % p != 0]\ndef is_prime(q, k=50):\n    q = abs(q)\n    if q == 2: return True\n    if q < 2 or q & 1 == 0: return False\n    d = (q - 1) >> 1\n    while d & 1 == 0:\n        d >>= 1\n    for i in range(k):\n        a = random.randint(1, q - 1)\n        t = d\n        y = pow(a, t, q)\n        while t != q - 1 and y != 1 and y != q - 1:\n            y = pow(y, 2, q)\n            t <<= 1\n        if y != q - 1 and t & 1 == 0:\n            return False\n    return True\ndef solve():\n    X = int(input())\n    if is_prime(X):\n        print(X)\n    else:\n        primes = eratosthenes(100010)\n        index = bisect_left(primes, X)\n        print(primes[index])\nif __name__ == '__main__':\n    solve()",
        "submission_id": "s320809427",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 40
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02825",
        "code_tokens": "N=int(input())\nans=[[\".\" for i in range(N)] for j in range(N)]\nif N==2 or N==7:\n    print(-1)\n    exit()\nelif N%3==0:\n    if N%3==0:\n        for i in range(N//3):\n            ans[3*i][3*i]=\"a\"\n            ans[3*i][3*i+1]=\"a\"\n            ans[3*i+1][3*i+2]=\"a\"\n            ans[3*i+2][3*i+2]=\"a\"\nelse:\n    r=5-N%5\n    if r==5:\n        r=0\n    for i in range(0,r):\n        ans[4*i][4*i]=\"a\"\n        ans[4*i][4*i+1]=\"a\"\n        ans[4*i][4*i+2]=\"c\"\n        ans[4*i][4*i+3]=\"d\"\n        ans[4*i+1][4*i]=\"b\"\n        ans[4*i+1][4*i+1]=\"b\"\n        ans[4*i+1][4*i+2]=\"c\"\n        ans[4*i+1][4*i+3]=\"d\"\n        ans[4*i+2][4*i]=\"c\"\n        ans[4*i+2][4*i+1]=\"d\"\n        ans[4*i+2][4*i+2]=\"a\"\n        ans[4*i+2][4*i+3]=\"a\"\n        ans[4*i+3][4*i]=\"c\"\n        ans[4*i+3][4*i+1]=\"d\"\n        ans[4*i+3][4*i+2]=\"b\"\n        ans[4*i+3][4*i+3]=\"b\"\n    for i in range((N-4*r)//5):\n        ans[5*i+4*r][5*i+4*r:5*i+4*r+5]=[\"a\",\"a\",\"b\",\"b\",\"c\"]\n        ans[5*i+4*r+1][5*i+4*r:5*i+4*r+5]=[\"b\",\"d\",\"d\",\".\",\"c\"]\n        ans[5*i+4*r+2][5*i+4*r:5*i+4*r+5]=[\"b\",\".\",\".\",\"e\",\"b\"]\n        ans[5*i+4*r+3][5*i+4*r:5*i+4*r+5]=[\"c\",\".\",\".\",\"e\",\"b\"]\n        ans[5*i+4*r+4][5*i+4*r:5*i+4*r+5]=[\"c\",\"b\",\"b\",\"a\",\"a\"]\nfor i in range(N):\n    print(\"\".join(ans[i]))",
        "submission_id": "s092313033",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 41
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03245",
        "code_tokens": "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda :sys.stdin.readline().rstrip()\ndef resolve():\n    n=int(input())\n    XY=[tuple(map(int,input().split())) for _ in range(n)]\n    parity=[0]*2\n    for x,y in XY:\n        parity[(x+y)%2]=1\n    if(parity[0] and parity[1]):\n        print(-1)\n        return\n    m=31\n    D=[pow(2,i) for i in range(m)]\n    W=[0]*m\n    if(parity[0]):\n        XY=[(x-1,y) for x,y in XY]\n        D=[1]+D\n    U=[x-y for x,y in XY]\n    V=[x+y for x,y in XY]\n    for j in range(n): \n        res=[0]*m\n        u=(U[j]+pow(2,m)-1)//2\n        v=(V[j]+pow(2,m)-1)//2\n        for i in range(m):\n            ub=u&1; vb=v&1\n            if(ub and vb):\n                res[i]='R'\n            elif(ub and (not vb)):\n                res[i]='D'\n            elif((not ub) and vb):\n                res[i]='U'\n            else:\n                res[i]='L'\n            u>>=1; v>>=1\n        W[j]=''.join(res)\n    m=m+parity[0]\n    print(m)\n    for d in D: print(d)\n    for j in range(n):\n        ans=W[j] if(parity[1]) else 'R'+W[j]\n        print(ans)\nresolve()",
        "submission_id": "s875124845",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 45
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02937",
        "code_tokens": "from heapq import heappush, heappop\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations\nimport sys\nimport bisect\nimport string\nsys.setrecursionlimit(10**6)\ndef SI():\n    return input().split()\ndef MI():\n    return map(int,input().split())\ndef I():\n    return int(input())\ndef LI():\n    return [int(i) for i in input().split()]\nYN=['Yes','No']\nmo=10**9+7\nalp=string.ascii_lowercase\nd_al=dict([(i,j) for j,i in enumerate(alp)])\ns=[d_al[i] for i in input()]\nt=[d_al[i] for i in input()]\nSs=set(s)\nSt=set(t)\nns=len(s)\nnt=len(t)\nss=s*2\ng=[{} for _ in range(ns)]\npos=[-1]*26\nfor i in range(ns*2)[::-1]:\n    for j in Ss:\n        if i<ns:\n            g[i][j]=pos[j]-i\n    pos[ss[i]]=i\nif len(St-Ss)!=0:\n    ans=-1\nelse:\n    cur=0\n    ans=1+g[-1][t[0]]\n    cur+=g[-1][t[0]]\n    for i in range(1,nt):\n        ans+=g[cur][t[i]]\n        cur+=g[cur][t[i]]\n        cur%=ns\nprint(ans)",
        "submission_id": "s889116887",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 45
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02269",
        "code_tokens": "class HashTable(dict):\n    def __init__(self, length):\n        dict.__init__(self)\n        self.length = length\n    def h1(self, key):\n        return key % self.length\n    def h2(self, key):\n        return 1 + (key % (self.length - 1))\n    def h(self, key, i):\n        return (self.h1(key) + i*self.h2(key)) % self.length\n    def insert(self, key):\n        i = 0\n        while True:\n            j = self.h(key, i)\n            if self[j] is None:\n                self[j] = key\n                return j\n            else:\n                i += 1\n    def search(self, key):\n        i = 0\n        while True:\n            j = self.h(key, i)\n            if self[j] == key:\n                return j\n            elif self[j] is None or i >= self.length:\n                return None\n            else:\n                i += 1\ndef getNum(char):\n    char2num = str.maketrans(\"ACGT\", \"1234\")\n    return int(char.translate(char2num))\nif __name__ == '__main__':\n    n = int(input())\n    T = HashTable(n)\n    C = [input().split(\" \") for i in range(n)]\n    C = map(lambda x:(x[0], getNum(x[1])), C)\n    for command, num in C:\n        if command == \"insert\":\n            T.insert(num)\n        else:\n            if T.search(num) is None:\n                print(\"no\")\n            else:\n                print(\"yes\")",
        "submission_id": "s266057883",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 45
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02822",
        "code_tokens": "from collections import defaultdict,deque\nimport sys\nimport math\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\nmod = 1000000007\ndef solve():\n    def dfs(x):\n        res = 1\n        for y in v[x]:\n            if d[y]:\n                d[y] = 0\n                res += dfs(y)\n        t[x] = res\n        return res\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    t = [0]*n\n    d = [1]*n\n    d[0] = 0\n    dfs(0)\n    ans = 0\n    p = pow(2,n-1,mod)\n    for x in range(n):\n        tx = t[x]\n        if len(v[x]) < 2:\n            continue\n        s = p-1\n        for y in v[x]:\n            ty = t[y]\n            if tx < ty:\n                s -= pow(2,t[0]-tx,mod)-1\n            else:\n                s -= pow(2,ty,mod)-1\n            s %= mod\n        ans += s\n        ans %= mod\n    print(ans*pow(2,(mod-2)*n,mod)%mod)\n    return\nif __name__ == \"__main__\":\n    solve()",
        "submission_id": "s952533884",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 47
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p01130",
        "code_tokens": "from heapq import heapify, heappop, heappush\nfrom operator import add\nwhile True:\n    n, m, s, g1, g2 = map(int, input().split())\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    if not n:\n        break\n    pipes = [set() for _ in range(n)]\n    for _ in range(m):\n        b1, b2, c = map(int, input().split())\n        b1 -= 1\n        b2 -= 1\n        pipes[b1].add((c, b2))\n        pipes[b2].add((c, b1))\n    dists = [[None] * n for _ in range(2)]\n    for i in (0, 1):\n        g = (g1, g2)[i]\n        dist = dists[i]\n        dist[g] = 0\n        queue = list(pipes[g])\n        heapify(queue)\n        while queue:\n            total_cost, base = heappop(queue)\n            if dist[base] is not None:\n                continue\n            dist[base] = total_cost\n            for next_cost, next_base in pipes[base]:\n                if dist[next_base] is None:\n                    heappush(queue, (total_cost + next_cost, next_base))\n    dists = list(map(add, *dists))\n    current_best = dists[s]\n    queue = list(pipes[s])\n    heapify(queue)\n    visited = {s}\n    while queue:\n        total_cost, base = heappop(queue)\n        if base in visited:\n            continue\n        visited.add(base)\n        current_best = min(current_best, total_cost + dists[base])\n        for next_cost, next_base in pipes[base]:\n            if next_base not in visited:\n                next_whole_cost = total_cost + next_cost + dists[next_base]\n                if current_best > next_whole_cost:\n                    heappush(queue, (total_cost + next_cost, next_base))\n    print(current_best)",
        "submission_id": "s136274975",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 48
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03591",
        "code_tokens": "h,w=map(int,input().split())\na={}\nfor i in range(26):\n  a[chr(i+97)]=0\nfor i in range(h):\n  s=input()\n  for j in s:\n    a[j]+=1\nif h==1 and w==1:print(\"Yes\")\nelif h==1 or w==1:\n  cnt=0\n  for i in a.values():\n    if i%2==1:cnt+=1\n  if cnt!=1:print(\"No\")\n  else:print(\"Yes\")\nelif h%2==0 and w%2==0:\n  for i in a.values():\n    if i%4!=0:print(\"No\");exit()\n  print(\"Yes\")\nelif h%2==1 and w%2==0:\n  cnt=0\n  for i in a.values():\n    if i%4==1 or i%4==3:\n      print(\"No\");exit()\n    if i%4==2:cnt+=1\n  if cnt>w//2:\n    print(\"No\")\n  else:print(\"Yes\")\nelif h%2==0 and w%2==1:\n  cnt=0\n  for i in a.values():\n    if i%4==1 or i%4==3:\n      print(\"No\");exit()\n    if i%4==2:cnt+=1\n  if cnt>h//2:\n    print(\"No\")\n  else:print(\"Yes\")\nelse:\n  cnt3=0;cnt2=0;cnt1=0\n  for i in a.values():\n    if i%4==1:cnt1+=1\n    elif i%4==2:cnt2+=1\n    elif i%4==3:cnt3+=1\n  rem=1-cnt1\n  elif cnt1+cnt3!=1:print(\"No\")\n  elif cnt2+cnt3>h+w-2:print(\"No\")\n  else:\n    print(\"Yes\")",
        "submission_id": "s525104116",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 48
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02866",
        "code_tokens": "class SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n    def update(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\nn,m=map(int, input().split())\nxs = []\nfor _ in range(m):\n    L, R, C = map(int, input().split())\n    xs.append((L-1, R-1, C))\nxs.sort()\nmx = 10**15\nss = SegTree([0] + [mx] * n, n+1, mx, min)\nfor l, r, c in xs:\n    mm = ss.query(l, n+1)\n    nx = min(mm + c, ss.query(r, r+1))\n    ss.update(r, nx)\nr = ss.query(n-1,n)\nprint(r if r != mx else -1)",
        "submission_id": "s989449428",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 49
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p00178",
        "code_tokens": "end = [1,1,1,1,1]\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  mp = [[0] * 5 for _ in range(4000)]\n  height = [0] * 5\n  cnt = 0\n  for i in range(n):\n    d, p, q = map(int, input().split())\n    q -= 1\n    cnt += p\n    if d == 1:\n      pos = max(height[q:q + p])\n      mp[pos][q:q + p] = [1] * p\n      if mp[pos] == end:\n        cnt -= 5\n        mp.pop(pos)\n        mp.append([0] * 5)\n        for x in range(5):\n          for y in range(i * 5 - 1, -1, -1):\n            if mp[y][x] == 1:\n              height[x] = y + 1\n              break\n          else:\n            height[x] = 0\n      else:\n        height[q:q + p] = [pos + 1] * p\n    if d == 2:\n      pop_flag = False\n      pos = height[q]\n      for y in range(pos, pos + p):\n        mp[y][q] = 1\n      for y in range(pos + p - 1, pos - 1, -1):\n        if mp[y] == end:\n          cnt -= 5\n          mp.pop(y)\n          mp.append([0] * 5)\n          pop_flag = True\n      if pop_flag:\n        for x in range(5):\n          for y in range(i * 5 - 1, -1, -1):\n            if mp[y][x] == 1:\n              height[x] = y + 1\n              break\n          else:\n            height[x] = 0\n      else:\n        height[q] += p\n  print(cnt)",
        "submission_id": "s330881806",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 50
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03441",
        "code_tokens": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nfrom bisect import bisect_left, bisect_right\nimport random\nfrom itertools import permutations, accumulate, combinations\nimport sys\nimport string\nfrom copy import deepcopy\nINF = 10 ** 20\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\nn=I()\nG=[[]for _ in range(n)]\nfor _ in range(n-1):\n    a,b=LI()\n    G[a]+=[b]\n    G[b]+=[a]\nvisited=[0]*n\na=[0]*n\nvisited[0]=1\nprint(G[2])\ndef f(x):\n    ret=0\n    cnt=0\n    for v in G[x]:\n        if visited[v]:\n            continue\n        visited[v] = 1\n        r=f(v)\n        ret+=r\n        if r==0:\n            cnt+=1\n    if cnt>1:\n        ret+=cnt-1\n    a[x]=ret\n    return ret\nans=f(0)\nif len(G[0]) == 1:\n    ans+=1\nprint(ans)",
        "submission_id": "s368162616",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 50
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03241",
        "code_tokens": "import sys\nfrom collections import deque\nimport copy\nimport math\nimport numpy as np\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\ndef make_divisor_list(num):\n    if num < 1:\n        return []\n    elif num == 1:\n        return [1]\n    else:\n        divisor_list = []\n        divisor_list.append(1)\n        for i in range(2, min(num // 2, 100000) + 1):\n            if num % i == 0:\n                divisor_list.append(i)\n        divisor_list.append(num)\n        return divisor_list\ndef is_prime(x):\n    if x < 2: return False \n    if x == 2 or x == 3 or x == 5: return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0: return False\n    prime = 7\n    step = 4\n    while prime <= math.sqrt(x):\n        if x % prime == 0: return False\n        prime += step\n        step = 6 - step\n    return True\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [int(input_raw[0]), int(input_raw[1])]\n    if N == 1:\n        print M\n        exit()\n    if is_prime(M):\n        print 1\n        exit()\n    for num in range(M/N, 0, -1):\n        if M % num == 0 and M/num >= N:\n            print num\n            exit()\nif __name__ == '__main__':\n    main()",
        "submission_id": "s727693417",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 54
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02822",
        "code_tokens": "import sys\nread = sys.stdin.buffer.read\ninput = sys.stdin.readline\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10**9)\nfrom functools import lru_cache\ndef RD(): return sys.stdin.read()\ndef II(): return int(input())\ndef MI(): return map(int,input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int,input().split()))\ndef LF(): return list(map(float,input().split()))\ndef TI(): return tuple(map(int,input().split()))\ndef main():\n\tmod=10**9+7\n\tn=II()\n\tG=[[] for _ in range(n+1)]\n\te=[]\n\tv=[0]*(n+1)\n\tp=[0]*(n+1)\n\tfor _ in range(n-1):\n\t\ta,b=MI()\n\t\tG[a].append(b)\n\t\tG[b].append(a)\n\t\te.append([a,b,0])\n\t@lru_cache(maxsize=None)\n\tdef tree(a):\n\t\tcnt=1\n\t\tfor i in G[a]:\n\t\t\tif p[a]==i:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tp[i]=a\n\t\t\t\tcnt+=tree(i)\n\t\tv[a]=cnt\n\t\treturn cnt\n\ttree(1)\n\tfor i in range(n-1):\n\t\ta=e[i][0]\n\t\tb=e[i][1]\n\t\te[i][2]=min(v[a],v[b])\n\tex=0\n\tfor _,_,c in e:\n\t\tex+=(1-0.5**c)*(1-0.5**(n-c))\n\tex+=1-0.5**n-n/2\n\tex=int(ex*2**n+0.5)\n\tfor i in range(1,n+1):\n\t\tif ex%2==0:\n\t\t\tex//=2\n\t\telse:\n\t\t\ti-=1\n\t\t\tbreak\n\ty=ex\n\tx=2**(n-i)\n\ty%=mod\n\tx%=mod\n\tans=y*pow(x,mod-2,mod)%mod\n\tprint(ans)\nif __name__ == \"__main__\":\n\tmain()",
        "submission_id": "s172524145",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 60
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03318",
        "code_tokens": "list1=[]\nfor i in range(1,200):\n    if i<=9:\n        list1.append(i)\n    elif i%10==0:\n        pass\n    elif i<=19:\n        a=(i-10)*10+9\n        list1.append(a)\n    elif i<=29:\n        a=(i-20)*100+99\n        list1.append(a)\n    elif i<=39:\n        a=(i-30)*1000+999\n        list1.append(a)\n    elif i<=49:\n        a=(i-40)*10000+9999\n        list1.append(a)\n    elif i<=59:\n        a=(i-50)*100000+99999\n        list1.append(a)\n    elif i<=69:\n        a=(i-60)*1000000+999999\n        list1.append(a)\n    elif i<=79:\n        a=(i-70)*10000000+9999999\n        list1.append(a)\n    elif i<=89:\n        a=(i-80)*100000000+99999999\n        list1.append(a)\n    elif i<=99:\n        a=(i-90)*1000000000+999999999\n        list1.append(a)\n    elif i<=109:\n        a=(i-100)*10000000000+9999999999\n        list1.append(a)\n    elif i<=119:\n        a=(i-110)*100000000000+99999999999\n        list1.append(a)\n    elif i<=129:\n        a=(i-120)*1000000000000+999999999999\n        list1.append(a)\n    elif i<=139:\n        a=(i-130)*10000000000000+9999999999999\n        list1.append(a)\n    elif i<=149:\n        a=(i-140)*100000000000000+99999999999999\n        list1.append(a)\n    elif i<=159:\n        a=(i-150)*1000000000000000+999999999999999\n        list1.append(a)\n    elif i<=169:\n        a=(i-160)*10000000000000000+9999999999999999\n        list1.append(a)\n    elif i<=179:\n        a=(i-170)*100000000000000000+99999999999999999\n        list1.append(a)\nK=int(input())\nfor j in range(K):\n    print(list1[j])",
        "submission_id": "s215054059",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 60
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p04030",
        "code_tokens": "import sys\nimport fractions\nimport copy\nimport bisect\nimport math\nimport numpy as np\nimport itertools\nfrom itertools import combinations_with_replacement\nfrom operator import itemgetter\nfrom sys import stdin\nfrom operator import mul\nfrom functools import reduce\nfrom collections import Counter\nj=0\nk=0\nn=3\nr=1\na=[0]\n\"1\u884c1\u3064\u306e\u6574\u6570\u3092\u5165\u529b\u3092\u53d6\u5f97\u3057\u3001\u6574\u6570\u3068\u53d6\u5f97\u3059\u308b\"\n\"12 21 332 \u3068\u304b\u5165\u529b\u3059\u308b\u6642\u306b\u4f7f\u3046\"\n\"1\u884c\u306b\u8907\u6570\u306e\u6574\u6570\u306e\u5165\u529b\u3092\u53d6\u5f97\u3057\u3001\u6574\u6570\u3068\u3057\u3066\u6271\u3046\"\n\"\u5217\u6570\u306b\u95a2\u3057\u3066\u81ea\u7531\u5ea6\u306e\u9ad8\u3044int\u578b\u306e\u5024\u3092\u5165\u529b\u3059\u308b\u30bf\u30a4\u30d7\u306e\u884c\u5217\"\n\"a\u3068\u3044\u3046\u5909\u6570\u306b\u5165\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u5927\u6587\u5b57\u306b\u3057\u3066\u51fa\u529b\"\ndef is_prime(n):\n    if n == 1: return False\n    for k in range(2, int(np.sqrt(n)) + 1):\n        if n % k == 0:\n            return False\n    return True\ndef factorial(x, mod=10**9+7):\n    tmp = 1\n    for i in range(1, x+1):\n        tmp = (tmp * i) % mod\n    return tmp\ndef main():\n    n=3\n    steps=0\n    state=0\n    w=1\n    j=0\n    k=0\n    s=input()\n    a=[i for i in s]\n    n=len(s)\n    c=[]\n    for i in range(n):\n        if a[i]==\"0\":\n           c.append(\"0\")\n        elif a[i]==\"1\":\n           c.append(\"1\")\n        elif a[i]==(\"B\"):\n           del c[-1]\n    print(\"\".join(c))\n    l = ['aaa', 'bbb', 'ccc']\n    x=l.index('aaa')\n    DP = np.zeros(w+1, dtype=int)\n    exdp=np.zeros((3,4)) \n    pin_l=[\"x\" for i in range(10)]\n    ls = [\"a\", \"b\", \"c\", \"d\", \"e\"]\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s103555384",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 61
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02753",
        "code_tokens": "from fractions import gcd \nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(200000000)\nfrom inspect import currentframe\ndef printargs2err(*args):\n    names = {id(v):k for k,v in currentframe().f_back.f_locals.items()}\n    print(', '.join(names.get(id(arg),'???')+' : '+repr(arg) for arg in args),file=sys.stderr)\ndef debug(*args):\n    print(*args,file=sys.stderr)\ndef printglobals():\n    for (symbol, value) in globals().items():\n        print('symbol=\"%s\"\u3001value=%s' % (symbol, value),file=sys.stderr)\ndef printlocals():\n    for (symbol, value) in locals().items():\n        print('symbol=\"%s\"\u3001value=%s' % (symbol, value),file=sys.stderr)\ndef pin(type=int):\n    return map(type,input().split())\nfrom collections import deque\nimport sys\ndef resolve():\n    S=deque(input())\n    Q,=pin()\n    ans=\"\"\n    turn=0\n    for i in range(Q):\n        q=sys.stdin.readline().rstrip().split()\n        if q[0]==\"1\":turn=(turn+1)%2\n        else:\n            f=int(q[1])%2\n            if f!=turn:\n                S.appendleft(q[2])\n            else:\n                S.append(q[2])\n    if turn==1:S.reverse()\n    for s in S:\n        ans+=s\n    print(ans)\nimport sys\nfrom io import StringIO\nimport unittest\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \n        output = \n        self.assertIO(input, output)\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \n        output = \n        self.assertIO(input, output)\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \n        output = \n        self.assertIO(input, output)\nif __name__==\"__main__\":resolve()",
        "submission_id": "s264985568",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 63
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03441",
        "code_tokens": "import sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\ndef getlist():\n\treturn list(map(int, input().split()))\nclass Graph(object):\n\tdef __init__(self):\n\t\tself.graph = defaultdict(list)\n\tdef __len__(self):\n\t\treturn len(self.graph)\n\tdef add_edge(self, a, b):\n\t\tself.graph[a].append(b)\n\tdef get_nodes(self):\n\t\treturn self.graph.keys()\ndef DFS(G, anstenna, edge_num, have, visit, node):\n\tcnt = 0\n\tfor i in G.graph[node]:\n\t\tif visit[i] != \"Yes\":\n\t\t\tvisit[i] = \"Yes\"\n\t\t\tDFS(G, anstenna, edge_num, have, visit, i)\n\t\t\tif have[i] == 1:\n\t\t\t\tcnt += 1\n\t\t\t\tanstenna[node] += anstenna[i]\n\tif cnt < edge_num[node] - 1:\n\t\tanstenna[node] += edge_num[node] - 1 - cnt\n\tif anstenna[node] >= 1:\n\t\thave[node] = 1\ndef main():\n\tN = int(input())\n\tG = Graph()\n\tfor i in range(N - 1):\n\t\ta, b = getlist()\n\t\ta -= 1; b -= 1\n\t\tG.add_edge(a, b)\n\t\tG.add_edge(b, a)\n\tif N == 2:\n\t\tprint(1)\n\t\treturn\n\tanstenna = [0] * (N + 1)\n\thave = [0] * (N + 1)\n\tedge_num = [len(G.graph[i]) - 1 for i in range(N + 1)]\n\tvisit = [\"No\"] * (N + 1)\n\tvisit[N] = \"Yes\"\n\ts = None\n\tfor i in range(N):\n\t\tif edge_num[i] >= 1:\n\t\t\ts = i\n\t\t\tbreak\n\tG.add_edge(N, s)\n\tG.add_edge(s, N)\n\tedge_num[s] += 1\n\tDFS(G, anstenna, edge_num, have, visit, N)\n\tans = anstenna[N]\n\tif edge_num[s] == 2:\n\t\tcnt = 0\n\t\tfor i in G.graph[s]:\n\t\t\tif have[i] == 1:\n\t\t\t\tcnt += 1\n\t\tif cnt <= 2:\n\t\t\tans += 1\n\tprint(ans)\nif __name__ == '__main__':\n\tmain()",
        "submission_id": "s361874018",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 64
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02866",
        "code_tokens": "BIGMOD = 998244353\ndef modPow(x,n):\n    ans = 1\n    while n >= 1:\n        if bin( n & 1)==bin(1):\n            ans = (ans*x) % BIGMOD\n        x = x * x % BIGMOD\n        n = n>>1\n    return ans % BIGMOD\ndef modFact(N):\n    fact = []\n    fact.append(1) \n    for i in range(1,N+1):\n        a = fact[i-1]*i % BIGMOD\n        fact.append(a)\n    return fact\ndef modInvFact(fact):\n    invFact = []\n    for i in range(1,N+2):\n        a = modPow(fact[i-1],BIGMOD-2)\n        invFact.append(a)\n    return invFact\ndef modPlus(a,b):\n    return (a + b) % BIGMOD\ndef modMinus(a,b):\n    if a-b >= 0:\n        return (a - b) % BIGMOD\n    else:\n        return (a - b + BIGMOD)\ndef modMulti(a,b):\n    return a * b % BIGMOD\ndef nCr(fact,invFact,n,r):\n    return (fact[n] * invFact[r] * invFact[n-r] ) %BIGMOD\ndef nPr(fact,invFact,n,r):\n    return(fact[n] * invFact[r])%BIGMOD\ndef fact(num):\n    ans = 1\n    for i in range(1,num+1):\n        ans = ans*i%BIGMOD\n    return ans\nimport collections\nN = int(input())\nD = list(map(int,input().split()))\nS = list(set(D))\nS.sort()\nif S[0]==0:\n    S.pop(0)\nans = 1\nbefore = 0\nbefore_i = 0\nc = collections.ounter(D)\nfor i in S:\n    if i == 1:\n        before = c[i]\n        before_i = i\n        continue\n    ans = ans*modPow(before,c[i])%BIGMOD\n    before = c[i]\n    if i - before_i!=1:\n        ans = 0\n    before_i = i\nif D[0] >0:\n    print(0)\nelse:\n    print(ans)",
        "submission_id": "s509105852",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 65
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02269",
        "code_tokens": "m1 = 1046527\n_dict = [\"\"] * m1\ndef insert(k):\n    i = 0\n    while True:\n        ix = _h(k, i)\n        if _dict[ix] == \"\":\n            _dict[ix] = k\n            return\n        else:\n            i += 1\ndef find(k):\n    i = 0\n    while True:\n        ix = _h(k, i)\n        if _dict[ix] == k:\n            return True\n        elif _dict[ix] == \"\":\n            return False\n        else:\n            i += 1\n    return False\ndef _h(k, i):\n    return ((k % m1) + i * (1 + k % (m1 - 1))) % m1\ndef getChar(ch):\n    if ch == 'A':\n        return 1\n    elif ch == 'C':\n        return 2\n    elif ch == 'G':\n        return 3\n    elif ch == 'T':\n        return 4\n    else:\n        return 0\ndef getKey(strings):\n    Sum = 0\n    p = 1\n    for i in xrange(len(strings)):\n        Sum += p * getChar(strings[i])\n        p *= 5\n    return Sum\ndef to_int(s):\n    ret = 0\n    i = 1\n    for j in range(len(s)):\n        e = s[len(s) - j - 1]\n        if e == 'A':\n            ret += 1 * i\n        elif e == 'C':\n            ret += 2 * i\n        elif e == 'G':\n            ret += 3 * i\n        elif e == 'T':\n            ret += 4 * i\n        i *= 5\n    return ret\nif __name__ == '__main__':\n    n = int(input())\n    for _ in range(n):\n        cmd, val = input().split()\n        if cmd[0] == \"i\":\n            insert(getKey(val))\n        else:\n            ans = \"yes\" if find(getKey(val)) else \"no\"\n            print(ans)",
        "submission_id": "s488468234",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 66
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02600",
        "code_tokens": "import sys,math,cmath,time,itertools\nstart_time = time.time()\ndef solve():\n    n = inp(a)\n    q = 2199 - n\n    q = q // 200\n    print(q,\"-kyu\",sep = \"\")\ndef main():\n    global tt\n    if not ONLINE_JUDGE:\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    t = 1\n    for tt in range(t):\n        solve()\n    if not ONLINE_JUDGE:\n        print(\"Time Elapsed :\",time.time() - start_time,\"seconds\")\n        sys.stdout.close()\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    return(input().strip())\ndef invr():\n    return(map(int,input().split()))\ndef counter(a):\n    q = [0] * max(a)\n    for i in range(len(a)):\n        q[a[i] - 1] = q[a[i] - 1] + 1\n    return(q)\ndef counter_elements(a):\n    q = dict()\n    for i in range(len(a)):\n        if a[i] not in q:\n            q[a[i]] = 0\n        q[a[i]] = q[a[i]] + 1\n    return(q)\ndef string_counter(a):\n    q = [0] * 26\n    for i in range(len(a)):\n        q[ord(a[i]) - 97] = q[ord(a[i]) - 97],1\n    return(q)\ndef factors(n):\n    q = []\n    for i in range(1,int(n ** 0.5) + 1):\n        if n % i == 0: q.append(i); q.append(n // i)\n    return(list(sorted(list(set(q)))))\ndef prime_factors(n):\n    q = []\n    while n % 2 == 0: q.append(2); n = n // 2\n    for i in range(3,int(n ** 0.5) + 1,2):\n        while n % i == 0: q.append(i); n = n // i\n    if n > 2: q.append(n)\n    return(list(sorted(q)))\ndef transpose(a):\n    n,m = len(a),len(a[0])\n    b = [[0] * n for i in range(m)]\n    for i in range(m): \n        for j in range(n): \n            b[i][j] = a[j][i]\n    return(b)\nONLINE_JUDGE = __debug__\nif ONLINE_JUDGE:\n    input = sys.stdin.readline\nmain()",
        "submission_id": "s616191972",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 66
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03063",
        "code_tokens": "import sys, collections, bisect, math, itertools\nfrom fractions import gcd \nm = int(input())\na = [int(input()) for j in range(m+1)] \nbeki = 0\nwhile a[-1] == 0:\n    a.pop()\n    beki+=1\nif m != len(a)-1:\n    m = len(a)\n    a.append(0)\ndef get_sieve_of_eratosthenes(n):\n    if not isinstance(n, int):\n        raise TypeError('n is int type.')\n    if n < 2:\n        raise ValueError('n is more than 2')\n    prime = []\n    limit = math.sqrt(n)\n    data = [i + 1 for i in range(1, n)]\n    while True:\n        p = data[0]\n        if limit <= p:\n            return prime + data\n        prime.append(p)\n        data = [e for e in data if e % p != 0]\nallprimes = get_sieve_of_eratosthenes(10010)\nprimes=[]\ndef get_sieve_of_eratosthenes2():\n    prime = []\n    data = [i + 1 for i in range(1, 35000)]\n    c=abs(a[m])\n    while True:\n        p = data[0]\n        if 35000 <= p*p:\n            return prime + data\n        if c%p==0: primes.append(p)\n        prime.append(p)\n        data = [e for e in data if e % p != 0]\nprimes2=[]\ndef get_sieve_of_eratosthenes3():\n    prime = []\n    data = [i + 1 for i in range(1, 35000)]\n    c=abs(a[0])\n    while True:\n        p = data[0]\n        if 35000 <= p*p:\n            return prime + data\n        if c%p==0: primes2.append(p)\n        prime.append(p)\n        data = [e for e in data if e % p != 0]\nget_sieve_of_eratosthenes2()\nif len(primes) == 0 and abs(a[m]) != 1:\n    primes.append(abs(a[m]))\nif len(primes2) == 0 and abs(a[0]) != 1:\n    primes2.append(abs(a[0]))\nn=m\nif a[m]==0:\n    primes = allprimes\nprimes = primes + primes2\nfor p in primes:\n    if p > 10**4+5:\n        if sum([i%p for i in a]) == 0:\n            print(p)\n        continue\n    coeff = list(reversed(a))\n    while len(coeff) > p:\n        t=coeff.pop()\n        coeff[-p+1]+=t\n    if sum([i%p for i in coeff]) == 0:\n        print(p)",
        "submission_id": "s773851889",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 70
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03081",
        "code_tokens": "from collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return input().rstrip().split()\ndef S(): return list(input().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = 1e10\ndef solve():\n    def f0(x):\n        for td_ in td:\n            if td_[0] == s[x]:\n                if td_[1] == \"L\":\n                    x -= 1\n                else:\n                    x += 1\n            if x < 0:\n                return True\n        return False\n    def f1(x):\n        for td_ in td:\n            if td_[0] == s[x]:\n                if td_[1] == \"L\":\n                    x -= 1\n                else:\n                    x += 1\n            if x >= n:\n                return True\n        return False\n    n, q = LI()\n    s = S()\n    td = LSR(q)\n    ok = -1\n    ng = n\n    ans = n\n    while ng - ok > 1:\n        mid = (ng - ok) // 2 + ok\n        if f0(mid):\n            ok = mid\n        else:\n            ng = mid\n    ans -= ok  + 1\n    ok = n\n    ng = -1\n    while ok - ng > 1:\n        mid = (ok - ng) // 2 + ng\n        if f1(mid):\n            ok = mid\n        else:\n            ng = mid\n    ans -= n - ok\n    print(ans)\n    return\nif __name__ == '__main__':\n    solve()",
        "submission_id": "s665753421",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 70
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03194",
        "code_tokens": "N, P = [int(x) for x in input().split()]\nimport types, math, operator\nimport numpy as np\nfrom math import sqrt\nfrom collections import Counter\nfrom itertools import product\nfrom functools import reduce\nclass PrimeUtils:\n    @staticmethod\n    def _has_numpy():\n        g = globals()\n        m = g.get('np')\n        if m is not None and isinstance(m, types.ModuleType):\n            return  m.__name__ == 'numpy'\n        return False\n    @staticmethod\n    def _primes_sieve_pp(n):\n        sieve = [True] * (n + 1)\n        for i in range(2, int(sqrt(n)) + 1):\n            if sieve[i]:\n                for j in range(i * i, n + 1, i):\n                    sieve[j] = False\n        return [i for i, x in enumerate(sieve[2:], 2) if x]\n    @staticmethod\n    def _primes_sieve_np(n):\n        sieve = np.ones(n + 1, np.bool)\n        sieve[0] = sieve[1] = False\n        for i, v in enumerate(sieve[2:int(sqrt(n)) + 1], 2):\n            if v: sieve[i*i::i] = False\n        return np.nonzero(sieve)[0]\n    @staticmethod\n    def _primes_sieve_np_fast(n):\n        n += 1\n        sieve = np.ones(n//3 + (n%6 == 2), dtype=np.bool)\n        check_upper = int(sqrt(n)) // 3\n        for i, v in enumerate(sieve[1:check_upper + 1], 1):\n            if v:\n                k = (3*i + 1) | 1\n                sieve[k* k           //3::2*k] = False\n                sieve[k*(k-2*(i&1)+4)//3::2*k] = False\n        sieve[0] = False\n        return np.r_[2,3,((3*np.nonzero(sieve)[0] + 1)|1)]\n    @classmethod\n    def primes_sieve(cls, n):\n        if cls._has_numpy():\n            return cls._primes_sieve_np_fast(n)\n        else:\n            return cls._primes_sieve_pp(n)\n    @classmethod\n    def pfd(cls, n):\n        primes = cls.primes_sieve(math.floor(n ** (1/N)))\n        factors = []\n        cur = n\n        for p in primes:\n            while True:\n                div, rem = divmod(cur, p)\n                if rem == 0:\n                    factors.append(p)\n                    cur = div\n                else:\n                    break\n        return factors\n    @classmethod\n    def aliquots(cls, n):\n        pf = cls.pfd(n)\n        pfc = Counter(pf)\n        ppv = [[pow(p, i) for i in range(n+1)] for p,n in pfc.items()]\n        if not ppv:\n            return (1,)\n        else:\n            return map(lambda x: reduce(operator.imul, x), product(*ppv))\nfrom collections import Counter\nc = Counter(PrimeUtils.pfd(P))\nimport functools, operator, itertools\nprint(functools.reduce(operator.imul, itertools.chain([1], map(lambda x: x[0] ** (x[1]//N), filter(lambda x: x[1] >= N, c.items())))))",
        "submission_id": "s314581373",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 75
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02819",
        "code_tokens": "def is_prime_miller_rabin(n: int) -> bool:\n    if n < 2:\n        return False\n    elif n in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67}:\n        return True\n    elif (\n        n % 2 == 0\n        or n % 3 == 0\n        or n % 5 == 0\n        or n % 7 == 0\n        or n % 11 == 0\n        or n % 13 == 0\n        or n % 17 == 0\n        or n % 19 == 0\n        or n % 23 == 0\n        or n % 29 == 0\n        or n % 31 == 0\n        or n % 37 == 0\n        or n % 41 == 0\n        or n % 43 == 0\n        or n % 47 == 0\n        or n % 53 == 0\n        or n % 59 == 0\n        or n % 61 == 0\n        or n % 67 == 0\n    ):\n        return False\n    if n < 2_047:\n        witnesses = [2]\n    elif n < 1_373_653:\n        witnesses = [2, 3]\n    elif n < 9_080_191:\n        witnesses = [31, 73]\n    elif n < 25_326_001:\n        witnesses = [2, 3, 5]\n    elif n < 3_215_031_751:\n        witnesses = [2, 3, 5, 7]\n    elif n < 4_759_123_141:\n        witnesses = [2, 7, 61]\n    elif n < 1_122_004_669_633:\n        witnesses = [2, 13, 23, 1662803]\n    elif n < 2_152_302_898_747:\n        witnesses = [2, 3, 5, 7, 11]\n    elif n < 3_474_749_660_383:\n        witnesses = [2, 3, 5, 7, 11, 13]\n    elif n < 341_550_071_728_321:\n        witnesses = [2, 3, 5, 7, 11, 13, 17]\n    elif n < 3_825_123_056_546_413_051:\n        witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    elif n < 318_665_857_834_031_151_167_461:\n        witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    else:  \n        witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    d = n - 1\n    d = d // (d & -d)\n    for a in witnesses:\n        y = pow(a, d, n)\n        if y == 1:\n            continue\n        t = d\n        while y != n - 1:\n            y = (y * y) % n\n            if y == 1 or t == n - 1:\n                return False\n            t <<= 1\n    return True\ndef main():\n    N = int(input())\n    if N != 2 and N % 2 == 0:\n        N += 1\n    while not is_prime_miller_rabin(N):\n        N += 2\n    print(N)\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s225053800",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 75
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03081",
        "code_tokens": "N = int(input())\ns = input()\nif s.count('R') > s.count('B'):\n    print('Yes')\nelse:\n    print('No')\nN,Q = map(int,input().split())\ns = input()\nq = [[0,0] for i in range(Q)]\nfor i in range(Q):\n    q[i] = input().split()\ndef L(n):\n    pos = n\n    for i in range(Q):\n        t,d = q[i]\n        if s[pos] == t:\n            if d == 'L':\n                pos -= 1\n            elif d == 'R':\n                pos += 1\n            if pos == -1:\n                return True\n            if pos == N:\n                return False\n    return False\ndef R(n):\n    pos = n\n    for i in range(Q):\n        t,d = q[i]\n        if s[pos] == t:\n            if d == 'L':\n                pos -= 1\n            elif d == 'R':\n                pos += 1\n            if pos == N:\n                return True\n            if pos == -1:\n                return False\n    return False\nn_mid = N//2\nn_l = 0\nn_r = N-1\nfor i in range(25):\n    if L(n_mid):\n        n_l = n_mid\n        n_mid = (n_l+n_r)//2\n    else:\n        n_r = n_mid\n        n_mid = (n_l+n_r)//2\nif not L(n_l):\n    l = -1\nelif L(n_r):\n    l = n_r\nelse:\n    l = n_l\nn_mid = N//2-1\nn_l = 0\nn_r = N-1\nfor i in range(25):\n    if R(n_mid):\n        n_r = n_mid\n        n_mid = (n_l+n_r)//2\n    else:\n        n_l = n_mid\n        n_mid = (n_l+n_r)//2\nif not R(n_r):\n    r = N\nelif R(n_l):\n    r = n_l\nelse:\n    r = n_r\nans = 0\nfor i in range(N):\n    if l < i < r:\n        ans += 1\nprint(ans)",
        "submission_id": "s609913326",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 76
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03729",
        "code_tokens": "import numpy as np\ndef generate():\n    newGen = np.zeros(n)\n    for p in range(pop):\n        gen = np.random.rand(n)\n        for i in range(n):\n            if gen[i] > 0.5:\n                gen[i] = 1\n            else:\n                gen[i] = 0\n        newGen = np.vstack([newGen,gen])\n    newGen = np.vsplit(newGen,[1])[1]\n    return newGen\ndef evaluate(gen):\n    sum = np.zeros(pop)\n    for p in range(pop):\n        for i in range(n):\n            sum[p] += v[i][1] * gen[p][i]\n    sum = sum.reshape(pop, 1)\n    gen = np.hstack([gen, sum])\n    return gen\ndef best(gen):\n    best0 = gen[0]\n    for p in range(1,pop):\n        if best0[-1] < gen[p][-1]:\n            best0 = gen[p]\n    return best0\ndef select(b,p):\n    parents = np.zeros(b.shape[1])\n    for i in range(p):\n        p1 = b[np.random.randint(0, b.shape[0] - 1)]\n        p2 = b[np.random.randint(0, b.shape[0] - 1)]\n        if p1[-1] < p2[-1]:\n            parents = np.vstack([parents, p2])\n        else:\n            parents = np.vstack([parents, p1])\n    return np.vsplit(parents,[1])[1]\ndef crossover(parents):\n    parents = np.hsplit(parents, [-1])[0]\n    newGen = np.zeros(parents.shape[1])\n    for i in range(parents.shape[0] / 2):\n        l = np.random.randint(1, parents.shape[1] - 1)\n        p1_0, p1_1 = np.hsplit(parents[i * 2], [l])\n        p2_0, p2_1 = np.hsplit(parents[i * 2 + 1], [l])\n        c1 = np.hstack([p1_0, p2_1])\n        c2 = np.hstack([p1_1, p2_0])\n        newGen = np.vstack([newGen, c1])\n        newGen = np.vstack([newGen, c2])\n    return np.vsplit(newGen, [1])[1]\ndef mutation(newGen):\n    for p in range(pop):\n        w_sum = 0\n        for i in range(n):\n            w_sum += newGen[p][i] * v[i][0]\n        if w_sum > w:\n            ran = np.random.permutation(np.arange(n))\n            while(w_sum > w):\n                ran, q = np.hsplit(ran,[-1])\n                if newGen[p][q] == 1:\n                    w_sum -= newGen[p][q] * v[q][0]\n                    newGen[p][q] = 0\n    return newGen\npop = 10\nn, w = map(int,raw_input().split())\nv = []\nN = 500\nfor i in range(n):\n    v.append(map(int,raw_input().split()))\neval = evaluate(generate())\nc = mutation(crossover(select(eval,pop)))\neval = evaluate(c)\nbe = best(eval)\nfor i in range(N):\n    c = mutation(crossover(select(eval,pop)))\n    eval = evaluate(c)\n    if be[-1] < best(eval)[-1]:\n        be = best(eval)\nprint int(be[-1])",
        "submission_id": "s513658190",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 78
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02942",
        "code_tokens": "import sys\nreadline = sys.stdin.readline\nimport collections\nclass Dinic:\n    def __init__(self, vnum):\n        self.edge = [[] for i in range(vnum)]\n        self.n = vnum\n        self.inf = float('inf')\n    def addedge(self, st, en, c):\n        self.edge[st].append([en, c, len(self.edge[en])])\n        self.edge[en].append([st, 0, len(self.edge[st])-1])\n    def bfs(self, vst):\n        dist = [-1]*self.n\n        dist[vst] = 0\n        Q = collections.deque([vst])\n        while Q:\n            nv = Q.popleft()\n            for vt, c, r in self.edge[nv]:\n                if dist[vt] == -1 and c > 0:\n                    dist[vt] = dist[nv] + 1\n                    Q.append(vt)\n        self.dist = dist\n    def dfs(self, nv, en, nf):\n        nextv = self.nextv\n        if nv == en:\n            return nf\n        dist = self.dist\n        ist = nextv[nv]\n        for i, (vt, c, r) in enumerate(self.edge[nv][ist:], ist):\n            if dist[nv] < dist[vt] and c > 0:\n                df = self.dfs(vt, en, min(nf, c))\n                if df > 0:\n                    self.edge[nv][i][1] -= df\n                    self.edge[vt][r][1] += df\n                    return df\n            nextv[nv] += 1\n        return 0\n    def getmf(self, st, en):\n        mf = 0\n        while True:\n            self.bfs(st)\n            if self.dist[en] == -1:\n                break\n            self.nextv = [0]*self.n\n            while True:\n                fl = self.dfs(st, en, self.inf)\n                if fl > 0:\n                    mf += fl\n                else:\n                    break\n        return mf\nN, M = map(int, readline().split())\nA = [list(map(int, readline().split())) for _ in range(N)]\nB = [[None]*M for _ in range(N)]\nunused = [set(range(N)) for _ in range(M)]\nst = 2*M\nen = 2*M+1\nfor i in range(N):\n    T = Dinic(2*M+2)\n    for j in range(M):\n        T.addedge(st, j, 1)\n        T.addedge(M+j, en, 1)\n        aj = (A[i][j]-1)//M\n        for ji in range(M):\n            if aj in unused[ji]:\n                T.addedge(j, M+ji, 1)\n    T.getmf(st, en)\n    for j in range(M):\n        candi = [e for e, cost, _ in T.edge[M+j] if cost == 1 and e != en]\n        B[i][j] = A[i][candi[0]]\n    for j in range(M):\n        unused[j].remove((B[i][j]-1)//M)\nC = list(map(list, zip(*B)))\nC = [sorted(c) for c in C]\nC = list(map(list, zip(*C)))\nfor b in B:\n    print(*b)\nfor c in C:\n    print(*c)",
        "submission_id": "s556371608",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 79
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02600",
        "code_tokens": "n = int(input())\nA = [list(input().split()) for i in range(n)]\nl = 2*10**5 + 5\nD = [[[] for j in range(2*l)] for i in range(4)]\nfor i in range(n):\n    x = int(A[i][0])\n    y = int(A[i][1])\n    nn = [x,y,A[i][2]]\n    D[0][x].append(nn)\n    D[1][y].append(nn)\n    D[2][x+y].append(nn)\n    D[3][x-y+l].append(nn)\nimport bisect\nans = float(\"inf\")\nfor i in range(l):\n    LR = [[], []]\n    for j in range(len(D[1][i])):\n        if D[1][i][j][2] == \"L\":\n            LR[0].append(D[1][i][j][0])\n        if D[1][i][j][2] == \"R\":\n            LR[1].append(D[1][i][j][0])\n        for k in range(len(LR[1])):\n            ind = bisect.bisect(LR[0], LR[1][k])\n            if ind != len(LR[0]):\n                ans = min(ans, (LR[0][ind]-LR[1][k]) * 5)\nfor i in range(l):\n    LR = [[], []]\n    for j in range(len(D[0][i])):\n        if D[0][i][j][2] == \"U\":\n            LR[0].append(D[0][i][j][1])\n        if D[0][i][j][2] == \"D\":\n            LR[1].append(D[0][i][j][1])\n        for k in range(len(LR[0])):\n            ind = bisect.bisect(LR[1], LR[0][k])\n            if ind != len(LR[1]):\n                ans = min(ans, (LR[1][ind]-LR[0][k]) * 5)\nfor i in range(2*l):\n    LR = [[], []]\n    LR2 = [[], []]\n    for j in range(len(D[2][i])):\n        if D[2][i][j][2] == \"L\":\n            LR[0].append(D[2][i][j][0])\n        if D[2][i][j][2] == \"D\":\n            LR[1].append(D[2][i][j][0])\n        if D[2][i][j][2] == \"U\":\n            LR2[0].append(D[2][i][j][0])\n        if D[2][i][j][2] == \"R\":\n            LR2[1].append(D[2][i][j][0])\n        for k in range(len(LR[1])):\n            ind = bisect.bisect(LR[0], LR[1][k])\n            if ind != len(LR[0]):\n                ans = min(ans, (LR[0][ind]-LR[1][k]) * 10)\n        for k in range(len(LR2[1])):\n            ind = bisect.bisect(LR2[0], LR2[1][k])\n            if ind != len(LR2[0]):\n                ans = min(ans, (LR2[0][ind]-LR2[1][k]) * 10)\nfor i in range(2*l):\n    LR = [[], []]\n    LR2 = [[], []]\n    for j in range(len(D[3][i])):\n        if D[3][i][j][2] == \"D\":\n            LR[0].append(D[3][i][j][1])\n        if D[3][i][j][2] == \"R\":\n            LR[1].append(D[3][i][j][1])\n        if D[3][i][j][2] == \"L\":\n            LR2[0].append(D[3][i][j][1])\n        if D[3][i][j][2] == \"U\":\n            LR2[1].append(D[3][i][j][1])\n        for k in range(len(LR[1])):\n            ind = bisect.bisect(LR[0], LR[1][k])\n            if ind != len(LR[0]):\n                ans = min(ans, (LR[0][ind]-LR[1][k]) * 10)\n        for k in range(len(LR2[1])):\n            ind = bisect.bisect(LR2[0], LR2[1][k])\n            if ind != len(LR2[0]):\n                ans = min(ans, (LR2[0][ind]-LR2[1][k]) * 10)\nif ans == float(\"inf\"):\n    ans = \"SAFE\"\nprint(ans)",
        "submission_id": "s501298289",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 79
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02269",
        "code_tokens": "sample_input = list(range(3))\nsample_input[0] = \nsample_input[1] = \nsample_input[2] = \ngive_sample_input = None\nif give_sample_input is not None:\n    sample_input_list = sample_input[give_sample_input].split('\\n')\n    def input():\n        return sample_input_list.pop(0)\nfrom collections import deque\ndef convert_ACGT_to_int(acgt_str):\n        result = 0\n        for char in acgt_str:\n            result *= 5\n            if char == 'A':\n                result += 1\n            elif char == 'C':\n                result += 2\n            elif char == 'G':\n                result += 3\n            elif char == 'T':\n                result += 4\n            else:\n                assert False\n        return result\ndef binary_search(increasing_list, elem):\n    index_min = 0\n    index_max = len(increasing_list) - 1\n    while index_max - index_min >= 2:\n        index_middle = int((index_min + index_max) / 2)\n        if increasing_list[index_middle] == elem:\n            return (True, index_middle + 1)\n        elif increasing_list[index_middle] > elem:\n            index_max = index_middle\n        else:\n            index_min = index_middle\n    if index_max >= index_min:\n        if increasing_list[index_max] == elem:\n            return (True, index_max + 1)\n        elif increasing_list[index_min] == elem:\n            return (True, index_min + 1)\n        elif increasing_list[index_max] < elem:\n            return (False, index_max + 1)\n        elif increasing_list[index_min] > elem:\n            return (False, index_min)\n        elif increasing_list[index_min] < increasing_list[index_max]:\n            return (False, index_max)\n        elif increasing_list[index_min] == increasing_list[index_max]:\n            val = increasing_list[index_min]\n            if elem < val:\n                return (False, index_min)\n            else:\n                return (False, index_max + 1)\n        else:\n            assert False\n    if index_max < index_min:\n        return (False, None)\nclass Dict (object):\n    def __init__(self):\n        self.data = deque()\n        pass\n    def insert(self, item):\n        index = binary_search(list(self.data), item)[1]\n        if index is None:\n            self.data.append(item)\n        else:\n            self.data.insert(index, item)\n    def find(self, item):\n        return binary_search(list(self.data), item)[0]\ndict = Dict()\nnum_of_commands = int(input())\nfor n in range(num_of_commands):\n    input_str = input()\n    command, data = input_str.split(' ')\n    if command == 'insert':\n        dict.insert(convert_ACGT_to_int(data))\n    else:\n        if dict.find(convert_ACGT_to_int(data)):\n            print('yes')\n        else:\n            print('no')",
        "submission_id": "s251716563",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 81
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02937",
        "code_tokens": "use std::io::stdin;\nuse std::time::SystemTime;\nuse std::collections::HashMap;\nfn read_line() -> String {\n    let mut s = String::new();\n    stdin().read_line(&mut s).unwrap();\n    s.trim().to_string()\n}\nfn read<T>() -> T\nwhere T: std::str::FromStr\n{\n    read_line().parse::<T>().ok().unwrap()\n}\nfn read_vec<T>() -> Vec<T>\nwhere T: std::str::FromStr\n{\n    read_line().split(\" \").map(|n| n.parse::<T>().ok().unwrap()).collect()\n}\nfn read_chars() -> Vec<char>\n{\n    read_line().chars().collect()\n}\nfn print_time() -> () {\n    println!(\"{:?}\", SystemTime::now());\n}\ntrait BinarySearchLeft<T> {\n    fn binary_search_left(&self, x: &T) -> Result<usize, usize>;\n}\nimpl<T> BinarySearchLeft<T> for Vec<T>\nwhere T: std::cmp::Ord + std::fmt::Debug\n{\n    fn binary_search_left(&self, x: &T) -> Result<usize, usize> {\n        let index = self.binary_search(x);\n        match index {\n            Ok(index) => {\n                for i in (1..index+1).rev() {\n                    if self[i] != self[i - 1] {\n                        return Ok(i - 1)\n                    }\n                }\n                Ok(index)\n            },\n            _ => index,\n        }\n    }\n}\nfn main() {\n    let s = read_chars();\n    let t = read_chars();\n    for p in t.iter() {\n        if !s.contains(p) {\n            println!(\"-1\");\n            return\n        }\n    }\n    let mut index = 0;\n    let mut counter = 0;\n    let mut ff = false;\n    let mut it = t.iter();\n    let mut c = it.next();\n    while true {\n        if ff {\n            ff = false;\n            c = it.next();\n        }\n        if let Some(c) = c {\n            let mut f = true;\n            for v in s.iter().skip(index) {\n                index += 1;\n                if c == v {\n                    f = false;\n                    ff = true;\n                    break;\n                }\n            }\n            if f {\n                index = 0;\n                counter += 1;\n            }\n        } else {\n            break;\n        }\n    }\n    println!(\"{}\", counter * s.len() + index);\n}",
        "submission_id": "s693506060",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 85
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03699",
        "code_tokens": "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nfrom collections import deque\nfrom fractions import gcd\nfrom functools import lru_cache\nMOD = 10**9+7\nINF = float('inf')\ndef inputI(): return int(input().strip())\ndef inputS(): return input().strip()\ndef inputIL(): return list(map(int,input().split()))\ndef inputSL(): return list(map(str,input().split()))\ndef inputILs(n): return list(int(input()) for _ in range(n))\ndef inputSLs(n): return list(input().strip() for _ in range(n))\ndef inputILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inputSLL(n): return [list(map(str, input().split())) for _ in range(n)]\ndef Yes(): print(\"Yes\")\ndef No(): print(\"No\")\ndef inv(n): return pow(n, MOD-2, MOD)\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n):\n    return kaijo_memo[n]\n  if(len(kaijo_memo) == 0):\n    kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n):\n    kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n):\n    return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0):\n    gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n):\n    gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\ndef nCr(n,r):\n  if(n == r):\n    return 1\n  if(n < r or r < 0):\n    return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\ndef lcm(a, b):\n    return a * b // gcd (a, b)\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n -1\n    count += 1\n  return count\nN = input()\nL = inputILs(N)\nL.sort()\nR = [l%10 for l in L]\nx = 0\nfor l in L:\n  if l%10 == 0:\n    continue\n  else:\n    x = l\n    break\nif x == 0:\n  print(x)\nelse:\n  print(sum(L)-x)",
        "submission_id": "s285129437",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 86
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02235",
        "code_tokens": "def prep_array(X, Y):\n    c = [[0]*1001 for _ in range(1000+1)]\n    return c\ndef check_max(array):\n    max_lcs = 0\n    for row in array:\n        temp_max = max(row)\n        if temp_max > max_lcs:\n            max_lcs = temp_max\n    return max_lcs\ndef calc_lcs4(X, Y, c):\n    X = ' ' + X\n    Y = ' ' + Y\n    m = len(X)\n    n = len(Y)\n    max_lcs = 0\n    pre_row = c[0]\n    for i in range(1, m):\n        row = c[i]\n        XX = X[i]\n        for j, YY in enumerate(Y):\n            if XX == YY:\n                row[j] = pre_row[j - 1] + 1\n                if row[j] > max_lcs:\n                    max_lcs = row[j]\n            elif pre_row[j] >= row[j - 1]:\n                row[j]= pre_row[j]\n            else:\n                row[j] = row[j - 1]\n        pre_row = row\n    return max_lcs\ndef calc_lcs3(X, Y, c):\n    m = len(X)\n    n = len(Y)\n    X = ' ' + X\n    Y = ' ' + Y\n    pre_row = c[0]\n    for i in range(1, m+1):\n        row = c[i]\n        XX = X[i]\n        for j in range(1, n+1):\n            if XX == Y[j]:\n                row[j] = pre_row[j - 1] + 1\n            elif pre_row[j] >= row[j - 1]:\n                row[j] = pre_row[j]\n            else:\n                row[j] = row[j - 1]\n        pre_row = row\n    return check_max(c)\ndef calc_lcs2(X, Y, c):\n    m = len(X)\n    n = len(Y)\n    X = ' ' + X\n    Y = ' ' + Y\n    pre_row = c[0]\n    for i in range(1, m+1):\n        row = c[i]\n        for j in range(1, n+1):\n            if X[i] == Y[j]:\n                row[j] = pre_row[j - 1] + 1\n            elif pre_row[j] >= row[j - 1]:\n                row[j] = pre_row[j]\n            else:\n                row[j] = row[j - 1]\n        pre_row = row\n    return check_max(c)\ndef calc_lcs(X, Y, c):\n    m = len(X)\n    n = len(Y)\n    X = ' ' + X\n    Y = ' ' + Y\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if X[i] == Y[j]:\n                c[i][j] = c[i - 1][j - 1] + 1\n            elif c[i - 1][j] >= c[i][j - 1]:\n                c[i][j] = c[i - 1][j]\n            else:\n                c[i][j] = c[i][j - 1]\n    return check_max(c)\nif __name__ == '__main__':\n    num = int(input())\n    for _ in range(num):\n        X = input()\n        Y = input()\n        ??????\n        result = calc_lcs4(X, Y, prep_array(X, Y))\n        print(result)",
        "submission_id": "s430767003",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 88
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03245",
        "code_tokens": "from sys import stdout\nfrom bisect import bisect_left as binl\nfrom copy import copy, deepcopy\ndef intin():\n    input_tuple = input().split()\n    if len(input_tuple) <= 1:\n        return int(input_tuple[0])\n    return tuple(map(int, input_tuple))\ndef intina():\n    return [int(i) for i in input().split()]\ndef intinl(count):\n    return [intin() for _ in range(count)]\ndef modadd(x, y):\n    global mod\n    return (x + y) % mod\ndef modmlt(x, y):\n    global mod\n    return (x * y) % mod\ndef lcm(x, y):\n    while y != 0:\n        z = x % y\n        x = y\n        y = z\n    return x\ndef get_divisors(x):\n    retlist = []\n    for i in range(1, int(x**0.5) + 3):\n        if x % i == 0:\n            retlist.append(i)\n            retlist.append(x // i)\n    return retlist\ndef make_linklist(xylist):\n    linklist = {}\n    for a, b in xylist:\n        linklist.setdefault(a, [])\n        linklist.setdefault(b, [])\n        linklist[a].append(b)\n        linklist[b].append(a)\n    return linklist\ndef calc_longest_distance(linklist, v=1):\n    distance_list = {}\n    distance_count = 0\n    distance = 0\n    vlist_previous = []\n    vlist = [v]\n    nodecount = len(linklist)\n    while distance_count < nodecount:\n        vlist_next = []\n        for v in vlist:\n            distance_list[v] = distance\n            distance_count += 1\n            vlist_next.extend(linklist[v])\n        distance += 1\n        vlist_to_del = vlist_previous\n        vlist_previous = vlist\n        vlist = list(set(vlist_next) - set(vlist_to_del))\n    max_distance = -1\n    max_v = None\n    for v, distance in distance_list.items():\n        if distance > max_distance:\n            max_distance = distance\n            max_v = v\n    return (max_distance, max_v)\ndef calc_tree_diameter(linklist, v=1):\n    _, u = calc_longest_distance(linklist, v)\n    distance, _ = calc_longest_distance(linklist, u)\n    return distance\ndef main():\n    n = intin()\n    xylist = intinl(n)\n    even_odd = None\n    for x, y in xylist:\n        tmp_even_odd = (x + y) % 2\n        if even_odd is None:\n            even_odd = tmp_even_odd\n            continue\n        if even_odd != tmp_even_odd:\n            print(-1)\n            return\n    m = 19 if even_odd else 20\n    print(m)\n    print(' '.join(['1'] * m))\n    for x, y in xylist:\n        xmove = 'R' * abs(x) if x > 0 else 'L' * abs(x)\n        ymove = 'U' * abs(y) if y > 0 else 'D' * abs(y)\n        remain_count = m - (abs(x) + abs(y))\n        remain_move = 'UD' * (remain_count // 2)\n        print(xmove + ymove + remain_move)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s301276890",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 90
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03832",
        "code_tokens": "import sys\nfrom collections import deque, defaultdict\nimport copy\nimport bisect\nimport math\nimport heapq\nfrom itertools import product, permutations,combinations\nimport fractions\nimport sys\ndef input():\n\treturn sys.stdin.readline().strip()\ndef pow(x, y, mod=1000000007):\n\tpow_list = [x]\n\ti = 1\n\twhile 2**i <= y:\n\t\ta = pow_list[-1]**2\n\t\tif mod != 0:\n\t\t\ta = a % mod\n\t\tpow_list.append(a)\n\t\ti += 1\n\tans = 1\n\tfor bit in range(len(pow_list)):\n\t\tif (2**bit) & y != 0:\n\t\t\tans *= pow_list[bit]\n\t\t\tif mod != 0:\n\t\t\t\tans = ans % mod\n\treturn ans\ndef fact(n, mod=100000007):\n\tans = 1\n\tfor i in range(n):\n\t\tans *= i + 1\n\t\tif mod != 0 and ans >= mod:\n\t\t\tans = ans % mod\n\treturn ans\ndef mod_rev(x, mod):\n\treturn pow(x, mod - 2, mod)\nN, A, B, C, D = list(map(int, input().split()))\nmod = 1000000007\nmod_sho = [0]\nfor i in range(N):\n\tmod_sho.append(mod_rev(i + 1, mod))\ncomb = [[0]*(N + 1) for _ in range(N + 1)]\ncomb[0][0] = 1\nfor n in range(1, N + 1):\n\tcomb[n][0] = 1\n\tcomb[n][n] = 1\n\tfor i in range(1, n):\n\t\tcomb[n][i] = comb[n - 1][i - 1] + comb[n - 1][i]\n\t\tcomb[n][i] = comb[n][i] % mod\nplus_list = []\nfor i in range(A, B + 1):\n\tG = []\n\tfor j in range(C, D + 1):\n\t\tif i*j > N:\n\t\t\tbreak\n\t\telse:\n\t\t\tG.append(i*j)\n\tif len(G) > 0:\n\t\tplus_list.append(G)\nsum = [0]*(N + 1)\nsum[0] = 1\nif len(plus_list) == 0:\n\tprint(0)\n\texit()\ntoc = time.time()\nnum = A - 1\nfor number in plus_list:\n\tnum += 1\n\tsum_next = [0] * (N + 1)\n\tfor n in range(0, N + 1):\n\t\tif sum[n] == 0:\n\t\t\tcontinue\n\t\tsum_next[n] += sum[n]\n\t\tsum_next[n] = sum_next[n] % mod\n\t\ttimes = 1\n\t\trest = N - n\n\t\tseki = 1\n\t\tfor x in number:\n\t\t\tif n + x <= N:\n\t\t\t\tseki *= comb[rest][num]\n\t\t\t\tseki = seki*mod_sho[times]\n\t\t\t\tseki = seki % mod\n\t\t\t\tsum_next[n + x] += (sum[n]*seki) % mod\n\t\t\t\tsum_next[n + x] = sum_next[n + x] % mod\n\t\t\t\ttimes += 1\n\t\t\t\trest -= num\n\t\t\telse:\n\t\t\t\tbreak\n\tsum = copy.deepcopy(sum_next)\nprint(sum[N])",
        "submission_id": "s726152986",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 90
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02900",
        "code_tokens": "from collections import deque\nfrom heapq import heapify,heappop,heappush,heappushpop\nfrom copy import copy,deepcopy\nfrom itertools import permutations,combinations\nfrom collections import defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom functools import reduce\nfrom pprint import pprint\ndef myinput():\n    return map(int,input().split())\ndef mylistinput(n):\n    return [ list(myinput()) for _ in range(n) ]\ndef mycol(data,col):\n    return [ row[col] for row in data ]\ndef mysort(data,col,reverse_flag):\n    data.sort(key=lambda x:x[col],reverse=reverse_flag)\n    return data\ndef mymax(data):\n    M = -1*float(\"inf\")\n    for i in range(len(data)):\n        m = max(data[i])\n        M = max(M,m)\n    return M\ndef mymin(data):\n    m = float(\"inf\")\n    for i in range(len(data)):\n        M = min(data[i])\n        m = min(m,M)\n    return m\ndef myoutput(ls,space=True):\n    if space:\n        if len(ls)==0:\n            print(\" \")\n        elif type(ls[0])==str:\n            print(\" \".join(ls))\n        elif type(ls[0])==int:\n            print(\" \".join(map(str,ls)))\n        else:\n            print(\"Output Error\")\n    else:\n        if len(ls)==0:\n            print(\"\")\n        elif type(ls[0])==str:\n            print(\"\".join(ls))\n        elif type(ls[0])==int:\n            print(\"\".join(map(str,ls)))\n        else:\n            print(\"Output Error\")\na,b = myinput()\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    return divisors\nls_a = make_divisors(a)\nls_b = make_divisors(b)\nls = list( set(ls_a) & set(ls_b) )\nls.sort()\ndef makePrimeChecker(n):\n    isPrime = [True] * (n + 1)\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if isPrime[i]:\n            for j in range(i * i, n + 1, i):\n                isPrime[j] = False\n    return isPrime\nif len(ls)==0:\n    print(0)\n    exit()\nM = ls[-1]\nif M==1:\n    print(1)\n    exit()\ntable = makePrimeChecker(M)\ncount = 0\nfor i in ls:\n    if i==1 or i==2:\n        count += 1\n    elif i%2==0:\n        pass\n    else:\n        if table[i]:\n            count += 1\n        else:\n            pass\nprint(count)",
        "submission_id": "s989002899",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 90
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02763",
        "code_tokens": "import sys\nfrom collections import defaultdict          \ndef main():\n    mod = 1000000007                  \n    inf = float('inf')\n    sys.setrecursionlimit(10**6)    \n    def input(): return sys.stdin.readline().rstrip()\n    def ii():  return int(input())\n    def mi():  return map(int, input().split())\n    def mi_0(): return map(lambda x: int(x)-1, input().split())\n    def lmi(): return list(map(int, input().split()))\n    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))\n    def li():  return list(input())\n    class SegTree:\n        def __init__(self, size):\n            self.size = size\n            self.n0 = 2 ** (size - 1).bit_length()\n            self.table = [defaultdict(int) for _ in range(2 * self.n0)]\n        @classmethod\n        def _p(cls, k):\n            return k // 2\n        @classmethod\n        def _l(cls, k):\n            return k * 2\n        @classmethod\n        def _r(cls, k):\n            return k * 2 + 1\n        @classmethod\n        def accumulate_to_defaultdict(cls, dd, result_dd):\n            for char, cnt in dd.items():\n                if cnt > 0:\n                    result_dd[char] += cnt\n        def update(self, k, new_char):\n            'update char in a_k to new_char'\n            table_k = k + self.n0 - 1\n            if self.table[table_k]:\n                previous_char = self.table[table_k].popitem()[0]\n                if previous_char != new_char:\n                    self.table[table_k][new_char] += 1\n                    while SegTree._p(table_k) > 0:\n                        table_k = SegTree._p(table_k)\n                        self.table[table_k][previous_char] -= 1\n                        self.table[table_k][new_char] += 1\n                else:\n                    self.table[table_k][previous_char] = 1    \n            else:\n                self.table[table_k][new_char] += 1\n                while SegTree._p(table_k) > 0:\n                    table_k = SegTree._p(table_k)                \n                    self.table[table_k][new_char] += 1\n        def range_set(self, l, r):\n            'return character counter dictionary ranging from a_l to a_r'\n            d = defaultdict(int)\n            table_l = l + self.n0 - 1\n            table_r = r + self.n0 - 1\n            if table_l > table_r:\n                raise RuntimeError(f\"l should be less than or equals to r. got l:{l} and r:{r}\")\n            while table_l < table_r:\n                if table_l & 0b1 == 1:\n                    SegTree.accumulate_to_defaultdict(self.table[table_l], d)\n                if table_r & 0b1 == 0:\n                    SegTree.accumulate_to_defaultdict(self.table[table_r], d)\n                table_l = SegTree._p(table_l + 1)\n                table_r = SegTree._p(table_r - 1)\n            if table_l == table_r:\n                SegTree.accumulate_to_defaultdict(self.table[table_l], d)\n            return d\n    def execute_query(seg_tree, L, buf):\n        id = int(L[0])\n        if id == 1:\n            i = int(L[1])\n            char = L[2]\n            seg_tree.update(i, char)\n        else:\n            i, j = map(int, L[1:])\n            d = seg_tree.range_set(i, j)\n            buf.append(len(d))\n    n = ii()\n    s = input()\n    q = ii()\n    commands = []\n    for _ in range(q):\n        commands.append(input().split())\n    st = SegTree(n)\n    for i, char in enumerate(s):\n        st.update(i+1, char)\n    buf = []\n    for query in commands:\n        execute_query(st, query, buf)\n    for elm in buf:\n        print(elm)\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s749862432",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 93
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03634",
        "code_tokens": "import sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(100000)\nINF = float(\"inf\")\nclass Graph(object):\n    def __init__(self, N):\n        self.N = N\n        self.edges = defaultdict(list)\n        pass\n    def add_edges(self, from_, to_, weight):\n        self.edges[from_].append([to_, weight])\n        self.edges[to_].append([from_, weight])\n        pass\ndef LCA_constract(g: Graph, root=0):\n    N = g.N\n    LN = int(math.log2(g.N))\n    par = [INF]*N\n    depth = [INF]*N\n    def dfs(curr, pre, dep):         \n        par[curr] = pre\n        depth[curr] = dep\n        for n, w in g.edges[curr]:\n            if n != pre:\n                dfs(n, curr, dep+w)\n    dfs(root, None, 0)\n    anc = [par]\n    for i in range(LN):\n        buf = [None]*N\n        for j in range(N):\n            if anc[i][j] == None:\n                continue\n            buf[j] = anc[i][anc[i][j]]\n        anc.append(buf)\n    return anc, depth\ndef LCA_query(anc, depth, u: int, v: int):\n    N = len(depth)\n    LN = int(math.log2(g.N))\n    dd = depth[v] - depth[u]\n    if dd < 0:\n        u, v = v, u\n        dd = -dd\n    for k in range(LN):\n        if dd & 1:\n            v = anc[k][v]\n        dd >>= 1\n    if u == v:\n        return u\n    for k in range(LN-1, -1, -1):\n        pu = anc[k][u]\n        pv = anc[k][v]\n        if pu != pv:\n            u = pu\n            v = pv\n    return anc[0][u]\ndef solve(N: int,\n          a: \"List[int]\",\n          b: \"List[int]\",\n          c: \"List[int]\",\n          Q: int,\n          K: int,\n          x: \"List[int]\",\n          y: \"List[int]\"):\n    g = Graph(N)\n    for aa, bb, cc in zip(a, b, c):\n        g.add_edges(*[aa-1, bb-1, cc])\n    anc, depth = LCA_constract(g, root=K-1)\n    for i in range(Q):\n        print(depth[x[i]-1]+depth[y[i]-1])\n    return\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  \n    a = [int()] * (N-1)  \n    b = [int()] * (N-1)  \n    c = [int()] * (N-1)  \n    for i in range(N-1):\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n        c[i] = int(next(tokens))\n    Q = int(next(tokens))  \n    K = int(next(tokens))  \n    x = [int()] * (Q)  \n    y = [int()] * (Q)  \n    for i in range(Q):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n    solve(N, a, b, c, Q, K, x, y)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s407195566",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 94
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03070",
        "code_tokens": "def main():\n\tN = int(input())\n\tA = [0]*N\n\tfor i in range(N):\n\t\tA[i] = int(input())\n\tmemo = dict()\n\tdef create_triangles(r, g, b, num):\n\t\tans = 0\n\t\tif num == N:\n\t\t\tif (abs(b-g)<r and r<b+g) or (abs(b-r)<g and g<b+r) or (abs(r-g)<b and b<r+g):\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tif not (r+A[num],g,b) in memo:\n\t\t\ttmp = create_triangles(r+A[num], g, b, num+1)\n\t\t\tmemo[(r+A[num],g,b)] = tmp\n\t\t\tmemo[(r+A[num],b,g)] = tmp\n\t\t\tmemo[(b,r+A[num],g)] = tmp\n\t\t\tmemo[(b,g,r+A[num])] = tmp\n\t\t\tmemo[(g,r+A[num],b)] = tmp\n\t\t\tmemo[(g,b,r+A[num])] = tmp\n\t\tans += memo[(r+A[num],g,b)]\n\t\tans %= 998244353\n\t\tif not (r,g+A[num],b) in memo:\n\t\t\ttmp = create_triangles(r, g+A[num], b, num+1)\n\t\t\tmemo[(r,g+A[num],b)] = tmp\n\t\t\tmemo[(r,b,g+A[num])] = tmp\n\t\t\tmemo[(b,r,g+A[num])] = tmp\n\t\t\tmemo[(b,g+A[num],r)] = tmp\n\t\t\tmemo[(g+A[num],r,b)] = tmp\n\t\t\tmemo[(g+A[num],b,r)] = tmp\n\t\tans += memo[(r,g+A[num],b)]\n\t\tans %= 998244353\n\t\tif not (r,g,b+A[num]) in memo:\n\t\t\ttmp = create_triangles(r, g, b+A[num], num+1)\n\t\t\tmemo[(r,g,b+A[num])] = tmp\n\t\t\tmemo[(r,b+A[num],g)] = tmp\n\t\t\tmemo[(b+A[num],r,g)] = tmp\n\t\t\tmemo[(b+A[num],g,r)] = tmp\n\t\t\tmemo[(g,r,b+A[num])] = tmp\n\t\t\tmemo[(g,b+A[num],r)] = tmp\n\t\tans += memo[(r,g,b+A[num])]\n\t\tans %= 998244353\n\t\treturn ans\n\tans = create_triangles(0,0,0,0)\n\tprint(ans)\nif __name__ == '__main__':\n    main()\ndef main():\n\tN = int(input())\n\tA = [0]*N\n\tfor i in range(N):\n\t\tA[i] = int(input())\n\tmemo = dict()\n\tdef create_triangles(r, g, b, num):\n\t\tans = 0\n\t\tif num == N:\n\t\t\tif (abs(b-g)<r and r<b+g) or (abs(b-r)<g and g<b+r) or (abs(r-g)<b and b<r+g):\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tif not (r+A[num],g,b) in memo:\n\t\t\ttmp = create_triangles(r+A[num], g, b, num+1)\n\t\t\tmemo[(r+A[num],g,b)] = tmp\n\t\t\tmemo[(r+A[num],b,g)] = tmp\n\t\t\tmemo[(b,r+A[num],g)] = tmp\n\t\t\tmemo[(b,g,r+A[num])] = tmp\n\t\t\tmemo[(g,r+A[num],b)] = tmp\n\t\t\tmemo[(g,b,r+A[num])] = tmp\n\t\tans += memo[(r+A[num],g,b)]\n\t\tans %= 998244353\n\t\tif not (r,g+A[num],b) in memo:\n\t\t\ttmp = create_triangles(r, g+A[num], b, num+1)\n\t\t\tmemo[(r,g+A[num],b)] = tmp\n\t\t\tmemo[(r,b,g+A[num])] = tmp\n\t\t\tmemo[(b,r,g+A[num])] = tmp\n\t\t\tmemo[(b,g+A[num],r)] = tmp\n\t\t\tmemo[(g+A[num],r,b)] = tmp\n\t\t\tmemo[(g+A[num],b,r)] = tmp\n\t\tans += memo[(r,g+A[num],b)]\n\t\tans %= 998244353\n\t\tif not (r,g,b+A[num]) in memo:\n\t\t\ttmp = create_triangles(r, g, b+A[num], num+1)\n\t\t\tmemo[(r,g,b+A[num])] = tmp\n\t\t\tmemo[(r,b+A[num],g)] = tmp\n\t\t\tmemo[(b+A[num],r,g)] = tmp\n\t\t\tmemo[(b+A[num],g,r)] = tmp\n\t\t\tmemo[(g,r,b+A[num])] = tmp\n\t\t\tmemo[(g,b+A[num],r)] = tmp\n\t\tans += memo[(r,g,b+A[num])]\n\t\tans %= 998244353\n\t\treturn ans\n\tans = create_triangles(0,0,0,0)\n\tprint(ans)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s578813498",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 96
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03014",
        "code_tokens": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,queue,copy\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\ndef main():\n  h,w=LI()\n  s=[S() for _ in range(h)]\n  L=[[0 for _ in range(w)]for __ in range(h)]\n  R=[[0 for _ in range(w)]for __ in range(h)]\n  D=[[0 for _ in range(w)]for __ in range(h)]\n  U=[[0 for _ in range(w)]for __ in range(h)]\n  for i in range(h):\n    for j in range(w):\n      if s[i][j]=='\n        L[i][j]=0\n        continue\n      if i==0:\n        U[i][j]=1\n      if j==0:\n        L[i][j]=1\n      if i!=0 and j!=0:\n        L[i][j]=L[i][j-1]+1\n        U[i][j]=U[i-1][j]+1\n  for i in range(h)[::-1]:\n    for j in range(w)[::-1]:\n      if s[i][j]=='\n        R[i][j]=0\n        continue\n      if i==h-1:\n        D[i][j]=1\n      if j==w-1:\n        R[i][j]=1\n      if i!=h-1 and j!=w-1:\n        R[i][j]=R[i][j+1]+1\n        D[i][j]=D[i+1][j]+1\n  ans=0\n  for i in range(h):\n    for j in range(w):\n      ans=max(ans,R[i][j]+L[i][j]+U[i][j]+D[i][j]-3)\n  return ans\nprint(main())\nimport math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,queue,copy\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\ndef main():\n  h,w=LI()\n  s=[S() for _ in range(h)]\n  L=[[0 for _ in range(w)]for __ in range(h)]\n  R=[[0 for _ in range(w)]for __ in range(h)]\n  D=[[0 for _ in range(w)]for __ in range(h)]\n  U=[[0 for _ in range(w)]for __ in range(h)]\n  for i in range(h):\n    for j in range(w):\n      if s[i][j]=='\n        L[i][j]=0\n        continue\n      if i==0:\n        U[i][j]=1\n      if j==0:\n        L[i][j]=1\n      if i!=0 and j!=0:\n        L[i][j]=L[i][j-1]+1\n        U[i][j]=U[i-1][j]+1\n  for i in range(h)[::-1]:\n    for j in range(w)[::-1]:\n      if s[i][j]=='\n        R[i][j]=0\n        continue\n      if i==h-1:\n        D[i][j]=1\n      if j==w-1:\n        R[i][j]=1\n      if i!=h-1 and j!=w-1:\n        R[i][j]=R[i][j+1]+1\n        D[i][j]=D[i+1][j]+1\n  ans=0\n  for i in range(h):\n    for j in range(w):\n      ans=max(ans,R[i][j]+L[i][j]+U[i][j]+D[i][j]-3)\n  return ans\nprint(main())",
        "submission_id": "s691241567",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 96
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02855",
        "code_tokens": "def main():\n    H, W, K = (int(i) for i in input().split())\n    c = [input() for j in range(H)]\n    from collections import deque\n    st = deque()\n    dist = [[-1]*W for i in range(H)]\n    berry = 0\n    for h in range(H):\n        for w in range(W):\n            if c[h][w] == '\n                berry += 1\n                st.append((h, w, berry))\n                dist[h][w] = 0\n    result = [[0]*W for _ in range(H)]\n    def bfs():\n        que = st\n        d = ((0, 1), (0, -1))\n        while que:\n            *u, b = que.popleft()\n            result[u[0]][u[1]] = b\n            for dy, dx in d:\n                next_y = u[0] + dy\n                next_x = u[1] + dx\n                if not(0 <= next_y < H and 0 <= next_x < W):\n                    continue\n                if dist[next_y][next_x] != -1:\n                    continue\n                if c[next_y][next_x] == '\n                    continue\n                dist[next_y][next_x] = dist[u[0]][u[1]] + 1\n                result[next_y][next_x] = b\n                que.append((next_y, next_x, b))\n    def bfs2():\n        que = st\n        d = ((1, 0), (-1, 0))\n        while que:\n            *u, b = que.popleft()\n            result[u[0]][u[1]] = b\n            for dy, dx in d:\n                next_y = u[0] + dy\n                next_x = u[1] + dx\n                if not(0 <= next_y < H and 0 <= next_x < W):\n                    continue\n                if dist[next_y][next_x] != -1:\n                    continue\n                if c[next_y][next_x] == '\n                    continue\n                dist[next_y][next_x] = dist[u[0]][u[1]] + 1\n                result[next_y][next_x] = b\n                que.append((next_y, next_x, b))\n    bfs()\n    allzero_flag = True\n    for i in range(H):\n        if result[i][0] != 0:\n            allzero_flag = False\n    if allzero_flag:\n        st = deque()\n        dist = [[-1]*W for i in range(H)]\n        berry = 0\n        for h in range(H):\n            for w in range(W):\n                if c[h][w] == '\n                    berry += 1\n                    st.append((h, w, berry))\n                    dist[h][w] = 0\n        result = [[0]*W for _ in range(H)]\n        bfs2()\n        for h in range(H):\n            for j in range(W):\n                cur = j\n                if result[h][w] != 0:\n                    print(result[h][w], end=\" \")\n                elif w < W - 1:\n                    while result[h][cur] == 0:\n                        cur += 1\n                    print(result[h][cur], end=\" \")\n                else:\n                    while result[h][cur] == 0:\n                        cur -= 1\n                    print(result[h][cur], end=\" \")\n            print()\n    else:\n        for i, r in enumerate(result):\n            cur = i\n            if i < H - 1 and result[i][0] == 0:\n                while result[cur][0] == 0:\n                    cur += 1\n                print(*result[cur])\n            elif 0 < i and result[i][0] == 0:\n                while result[cur][0] == 0:\n                    cur -= 1\n                print(*result[i-1])\n            else:\n                print(*r)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s954598093",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 96
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02305",
        "code_tokens": "class node():\n    def __init__(self, v, cost):\n        self.v = v\n        self.cost = cost\ninfty = 999999999\ndict_c = {}\n[vertex, edge, r] = list(map(int, input(\"\").split()))\nroot_c = [node(r, 0)]\nfinal_c = [infty for i in range(vertex)]\nfinal_c[r] = 0\nfor i in range(edge):\n    [e1, e2, c] = list(map(int, input(\"\").split()))\n    if e1 == r:\n        root_c.append(node(e2, c))\n        final_c[e2] = c\n    else:\n        dict_c[(e1, e2)] = c\ndef min_heap(i):\n    global root_c\n    l = 2*i\n    r = 2*i + 1\n    if l <= len(root_c) - 1 and root_c[l].cost <= root_c[i].cost:\n        if root_c[l].cost < root_c[i].cost:\n            min = l\n        elif root_c[l].v < root_c[i].v:\n            min = l\n        else:\n            min = i\n    else:\n        min = i\n    if r <= len(root_c) - 1 and root_c[r].cost <= root_c[min].cost:\n        if root_c[r].cost < root_c[min].cost:\n            min = r\n        elif root_c[r].v < root_c[min].v:\n            min = r\n    if min != i:\n        root_c[i], root_c[min] = root_c[min], root_c[i]\n        min_heap(min)\ndef build_min_heap():\n    global root_c\n    length = len(root_c) - 1\n    for i in range(int(length/2), 0, -1):\n        min_heap(i)\ndef extract_min():\n    global root_c\n    min = root_c[1]\n    root_c[1] = root_c[len(root_c) - 1]\n    del root_c[len(root_c) - 1]\n    min_heap(1)\n    return min\ndef decrease_key(i, c):\n    global root_c\n    root_c[i].cost = c\n    while i > 1 and root_c[int(i/2)].cost >= root_c[i].cost:\n        if root_c[int(i/2)].cost > root_c[i].cost:\n            root_c[int(i/2)], root_c[i] = root_c[i], root_c[int(i/2)]\n        elif root_c[int(i/2)].v > root_c[i].v:\n            root_c[int(i/2)], root_c[i] = root_c[i], root_c[int(i/2)]\n        else:\n            root_c[int(i/2)], root_c[i] = root_c[int(i/2)], root_c[i]\n        i = int(i/2)\ndef min_insert(v, c):\n    global infty, root_c\n    for i in range(1, len(root_c)):\n        if root_c[i].v == v:\n            decrease_key(i,c)\n            return\n    root_c.append(node(v, infty))\n    decrease_key(len(root_c) - 1, c)\ndef Dijkstra(root, n):\n    count = 1\n    global infty, dict_c, root_c, final_c\n    label = [i for i in range(n)]\n    count += 1\n    del label[root]\n    while len(label) != 0:\n        if len(root_c) > 1:\n            min_node = extract_min()\n        else:\n            break\n        for i in range(len(label)):\n            if min_node.v == label[i]:\n                delete_label = i\n                continue\n            if ((min_node.v, label[i]) in dict_c.keys()) == True:\n                if final_c[label[i]] > final_c[min_node.v] + dict_c[(min_node.v, label[i])]:\n                    final_c[label[i]] = final_c[min_node.v] + dict_c[(min_node.v, label[i])]\n                    min_insert(label[i], final_c[label[i]])\n        count += 1\n        del label[delete_label]\nbuild_min_heap()\nDijkstra(r, vertex)\nfor i in range(vertex):\n    if final_c[i] == infty:\n        print(\"INF\")\n    else:\n        print(final_c[i])",
        "submission_id": "s216292788",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 97
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02749",
        "code_tokens": "g = {}\nn=int(input())\nm = [-1]*n\ndef dfs(graph,node,height):\n    global m\n    global zeros\n    global ones\n    m[node-1]=height\n    if height==0:\n      zeros+=1\n    if height==1:\n      ones+=1\n    for n in graph[node]:\n      if m[n-1]==-1:\n        dfs(graph,n,1-height)\nzeros=0\nones=0\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  if not a in g:\n    g[a]=[b]\n  else:\n    g[a].append(b)\n  if not b in g:\n    g[b]=[a]\n  else:\n    g[b].append(a)\ndfs(g,1,0)\nans=[0]*n\nused=[0]*n\nif zeros<=n//3:\n  current=3\n  for i in range(n):\n    if m[i]==0:\n      ans[i]=current\n      current+=3\n      used[current-1]=1\n  counter=0\n  for i in range(n):\n    if m[i]==1:\n      while True:\n        if used[counter]==0:\n          ans[i]=counter+1\n          break\n        counter+=1\nelif ones<=n//3:\n  current=3\n  for i in range(n):\n    if m[i]==1:\n      ans[i]=current\n      current+=3\n      used[current-1]=1\n  counter=0\n  for i in range(n):\n    if m[i]==0:\n      while True:\n        if used[counter]==0:\n          ans[i]=counter+1\n          break\n        counter+=1\nelse:\n  if zeros<ones:\n    current=1\n    for i in range(n):\n      if m[i]==0:\n        ans[i]=current\n        used[current-1]=1\n        current+=3\n        if current>n:\n          current=3\n    counter=0\n    for i in range(n):\n      if m[i]==1:\n        while True:\n          if used[counter]==0:\n            ans[i]=counter+1\n            counter+=1\n            break\n          counter+=1\n  else:\n    current=1\n    for i in range(n):\n      if m[i]==1:\n        ans[i]=current\n        used[current-1]=1\n        current+=3\n        if current>n:\n          current=3\n      counter=0\n    for i in range(n):\n      if m[i]==0:\n        while True:\n          if used[counter]==0:\n            ans[i]=counter+1\n            counter+=1\n            break\n          counter+=1\nfor i in ans:\n  print(i)",
        "submission_id": "s550656484",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 99
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03208",
        "code_tokens": "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nMOD = 10**9+7\nINF = float('inf')\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\ndef DD(arg): return defaultdict(arg)\ndef inv(n): return pow(n, MOD-2, MOD)\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n):\n    return kaijo_memo[n]\n  if(len(kaijo_memo) == 0):\n    kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n):\n    kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n):\n    return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0):\n    gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n):\n    gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\ndef nCr(n,r):\n  if(n == r):\n    return 1\n  if(n < r or r < 0):\n    return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1:\n    arr.append([temp, 1])\n  if arr==[]:\n    arr.append([n, 1])\n  return arr\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  return divisors\ndef lcm(a, b):\n    return a * b // gcd (a, b)\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n -1\n    count += 1\n  return count\ndef base_10_to_n(X, n):\n  if X//n:\n    return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i])*n**i for i in range(len(str(X))))\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\nN,K = IL()\nT = ILs(N)\nT.sort()\nprint(min( T[i+K-1]-T[i] for i in range(N-K+1))",
        "submission_id": "s038199983",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 101
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02749",
        "code_tokens": "g = {}\nn=int(input())\nm = [-1]*n\ndef dfs(graph,node,height):\n    global m\n    global zeros\n    global ones\n    m[node-1]=height\n    if height==0:\n      zeros+=1\n    if height==1:\n      ones+=1\n    for n in graph[node]:\n      if m[n-1]==-1:\n        dfs(graph,n,1-height)\nzeros=0\nones=0\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  if not a in g:\n    g[a]=[b]\n  else:\n    g[a].append(b)\n  if not b in g:\n    g[b]=[a]\n  else:\n    g[b].append(a)\ndfs(g,1,0)\nans=[0]*n\nused=[0]*n\nr=n//3\nif 3*(r+1)<=n:\n  r+=1\nif zeros<=r:\n  current=3\n  for i in range(n):\n    if m[i]==0:\n      ans[i]=current\n      used[current-1]=1\n      current+=3\n  counter=0\n  for i in range(n):\n    if m[i]==1:\n      while True:\n        if used[counter]==0:\n          ans[i]=counter+1\n          counter+=1\n          break\n        counter+=1\nelif ones<=r:\n  current=3\n  for i in range(n):\n    if m[i]==1:\n      ans[i]=current\n      used[current-1]=1\n      current+=3\n  counter=0\n  for i in range(n):\n    if m[i]==0:\n      while True:\n        if used[counter]==0:\n          ans[i]=counter+1\n          counter+=1\n          break\n        counter+=1\nelse:\n  if zeros<ones:\n    current=1\n    for i in range(n):\n      if m[i]==0:\n        ans[i]=current\n        used[current-1]=1\n        current+=3\n        if current>n:\n          current=3\n    counter=0\n    for i in range(n):\n      if m[i]==1:\n        while True:\n          if used[counter]==0:\n            ans[i]=counter+1\n            counter+=1\n            break\n          counter+=1\n  else:\n    current=1\n    for i in range(n):\n      if m[i]==1:\n        ans[i]=current\n        used[current-1]=1\n        current+=3\n        if current>n:\n          current=3\n      counter=0\n    for i in range(n):\n      if m[i]==0:\n        while True:\n          if used[counter]==0:\n            ans[i]=counter+1\n            counter+=1\n            break\n          counter+=1\nfor i in ans:\n  print(i)",
        "submission_id": "s163226730",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 104
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02666",
        "code_tokens": "import sys\nimport numpy as np\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nMOD = 998244353\ndef fft_convolve(f, g, MOD=MOD):\n    fft = np.fft.rfft\n    ifft = np.fft.irfft\n    Lf = f.shape[-1]\n    Lg = g.shape[-1]\n    L = Lf + Lg - 1\n    fft_len = 1 << L.bit_length()\n    fl = f & (1 << 15) - 1\n    fh = f >> 15\n    gl = g & (1 << 15) - 1\n    gh = g >> 15\n    def conv(f, g):\n        return ifft(fft(f, fft_len) * fft(g, fft_len))[:, :L]\n    x = conv(fl, gl) % MOD\n    y = conv(fl + fh, gl + gh) % MOD\n    z = conv(fh, gh) % MOD\n    a, b, c = map(lambda x: (x + .5).astype(np.int64), [x, y, z])\n    return (a + ((b - a - c) << 15) + (c << 30)) % MOD\nclass UnionFindNode:\n    def __init__(self, group_id, parent=None, value=None):\n        self.group_id_ = group_id\n        self.parent_ = parent\n        self.value = value\n        self.rank_ = 1\n        self.member_num_ = 1\n    def is_root(self):\n        return not self.parent_\n    def root(self):\n        parent = self\n        while not parent.is_root():\n            parent = parent.parent_\n            self.parent_ = parent\n        return parent\n    def find(self):\n        root = self.root()\n        return root.group_id_\n    def rank(self):\n        root = self.root()\n        return root.rank_\n    def unite(self, unite_node):\n        root = self.root()\n        unite_root = unite_node.root()\n        if root.group_id_ != unite_root.group_id_:\n            if root.rank() > unite_root.rank():\n                n_root, child = root, unite_root\n            else:\n                n_root, child = unite_root, root\n            child.parent_ = n_root\n            n_root.rank_ = max(n_root.rank_, child.rank_ + 1)\n            n_root.member_num_ = n_root.member_num_ + child.member_num_\nmod = 10**9+7\nNNN = (10**6)\ng1 = [1, 1]\nfor i in range( 2, NNN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\nN, = map(int, input().split())\nP = list(map(int, input().split()))\nK = P.count(-1)\nnodes = [UnionFindNode(i) for i in range(N)]\nfor i, p in enumerate(P):\n    p-=1\n    if p >= 0:\n        nodes[p].unite(nodes[i])\nrs = []\nX = [0] * N\nfor i in range(N):\n    if nodes[i].is_root():\n        rs.append(i)\n    if P[i] == -1:\n        X[nodes[i].find()] = 1\nM = len(rs)\nR = N*pow(N-1, K, mod)%mod\nY = []\nfor i in range(M):\n    if X[rs[i]]:\n        Y.append(nodes[rs[i]].member_num_)\n        R = (R-(nodes[rs[i]].member_num_-1)*pow(N-1, K-1, mod))%mod\n    else:\n        R = (R-pow(N-1, K, mod))%mod\nnY = len(Y)\nA = np.array(Y, np.int64)\npolys = np.empty((nY, 2), np.int64)\npolys[:, 1] = 1\npolys[:, 0] = A\nwhile len(polys) > 1:\n    if len(polys) & 1:\n        polys = np.pad(polys, ((0, 1), (0, 0)))\n        polys[-1, 0] = 1\n    P = polys[:len(polys) // 2]\n    Q = polys[len(polys) // 2:]\n    polys = fft_convolve(P, Q)\nP = polys[0]\nfor i in range(nY):\n    if nY-i == 1:\n        continue\n    R -= pow(N-1, K-(nY-i), mod) * g1[nY-i-1] * P[i]\n    R %= mod\nprint(R)",
        "submission_id": "s814483568",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 104
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03427",
        "code_tokens": "import sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n    @staticmethod\n    def string_list(n):\n        return [input() for i in range(n)]\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n    @staticmethod\n    def int_cols_list(n):\n        return [int(input()) for i in range(n)]\nclass Math():\n    @staticmethod\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return Math.gcd(b, a % b)\n    @staticmethod\n    def lcm(a, b):\n        return (a * b) // Math.gcd(a, b)\n    @staticmethod\n    def roundUp(a, b):\n        return -(-a // b)\n    @staticmethod\n    def toUpperMultiple(a, x):\n        return Math.roundUp(a, x) * x\n    @staticmethod\n    def toLowerMultiple(a, x):\n        return (a // x) * x\n    @staticmethod\n    def nearPow2(n):\n        if n <= 0:\n            return 0\n        if n & (n - 1) == 0:\n            return n\n        ret = 1\n        while(n > 0):\n            ret <<= 1\n            n >>= 1\n        return ret\n    @staticmethod\n    def sign(n):\n        if n == 0:\n            return 0\n        if n < 0:\n            return -1\n        return 1\n    @staticmethod\n    def isPrime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        d = int(n ** 0.5) + 1\n        for i in range(3, d + 1, 2):\n            if n % i == 0:\n                return False\n        return True\nclass PriorityQueue:\n    def __init__(self, l=[]):\n        self.__q = l\n        heapq.heapify(self.__q)\n        return\n    def push(self, n):\n        heapq.heappush(self.__q, n)\n        return\n    def pop(self):\n        return heapq.heappop(self.__q)\nMOD = int(1e09) + 7\nINF = int(1e15)\ndef calc(N):\n    return sum(int(x) for x in str(N))\ndef main():\n    N = Scanner.int()\n    ans = calc(N)\n    ans = max(ans, calc(int(str(int(str(N)[0])-1) + \"9\" * (len(str(N)) - 1))))\n    ans = max(ans, calc(N - N % 10 - 1))\n    print(ans)\n    return\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s573558490",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 104
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02698",
        "code_tokens": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom pprint import pprint as pp\nfrom pprint import pformat as pf\nimport math\ndef binary_search(l, value, over):\n    if len(l) == 0:\n        return None, None\n    b = 0 \n    t = len(l) - 1 \n    if not over(l[t], value):\n        return None, None\n    while not (b == t):\n        head = b + ((t - b) // 2)\n        if over(l[head], value):\n            t = head\n        else:\n            b = head + 1\n    return b, l[b]\ndef first_over_or_same(l, value):\n    def over_or_same(a, b):\n        return a >= b\n    return binary_search(l, value, over_or_same)\nclass SolverLIS:\n    class Diff:\n        def __init__(self, dp_key, before_value):\n            self.dp_key = dp_key\n            self.before_value = before_value\n    def __init__(self):\n        self.dp = [0] \n        self.last_not_inf = 0\n        self.history = [None] \n    def append_last(self, value):\n        self.dp.append(math.inf)\n        self.history.append(None)\n        self.use(value)\n        return self.get_longest_increasing_subsequence_size()\n    def remove_last(self):\n        self.undo()\n        self.dp.pop(-1)\n        self.history.pop(-1)\n    def undo(self):\n        d = self.history[-1]\n        self.dp[d.dp_key] = d.before_value\n    def use(self, value):\n        key, over_value = first_over_or_same(self.dp, value)\n        if key is not None and over_value != value:\n            self.history[-1] = SolverLIS.Diff(key, self.dp[key])\n            self.dp[key] = value\n    def get_longest_increasing_subsequence_size(self):\n        def from_end():\n            length = len(self.dp) - 1\n            while length >= 0:\n                value = self.dp[length]\n                if value is not math.inf and value > 0:\n                    self.last_not_inf = length\n                    return\n                length -= 1\n            self.last_not_inf = 0\n        if not (len(self.dp) > self.last_not_inf):\n            from_end()\n        if self.dp[self.last_not_inf] is math.inf:\n            self.last_not_inf -= 1\n        elif (len(self.dp) > self.last_not_inf + 1) and self.dp[self.last_not_inf + 1] is not math.inf:\n            self.last_not_inf += 1\n        return self.last_not_inf\nclass Edges:\n    def __init__(self, num_node):\n        self.data = [None] * (num_node + 1) \n        for i, _ in enumerate(self.data):\n            self.data[i] = set()\n    def register(self, frm, to):\n        self.data[frm].add(to)\n        self.data[to].add(frm)\n    def get(self, frm):\n            return self.data[frm]\n    def __repr__(self):\n        out = \"\"\n        for i, s in enumerate(self.data):\n            out += \"{}:{}\".format(i, s.__repr__())\n        return out\ndef dps(node_values, edges):\n    solver = SolverLIS()\n    ans = [None] * (len(node_values)) \n    def _dps(node, bef):\n        ans[node] = solver.append_last(node_values[node])\n        for to in edges.get(node):\n            if to == bef:\n                continue\n            _dps(to, node)\n        solver.remove_last()\n    _dps(1, 0)\n    return ans\nif __name__ == '__main__':\n    n = int(input())\n    node_values = list(map(int, input().split()))\n    node_values.insert(0, 0) \n    edges = Edges(n)\n    for i in range(n - 1):\n        e = list(map(int, input().split()))\n        edges.register(*e)\n    path_list = dps(node_values, edges)\n    for a in path_list[1:]:\n        print(a)",
        "submission_id": "s199036368",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 104
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02900",
        "code_tokens": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys\nimport random\nimport itertools\nimport math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return list(map(list, input().split()))\ndef S(): return list(input().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\ndef gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\ndef gcdx(x, y):\n    g = 0\n    if (x % y != 0):\n        g = x % y\n        gcdx(y, g)\n    return g\nmod = 1000000007\ninf = float('INF')\ndef A():\n    a = II()\n    b = a//2\n    p = b/a\n    if a % 2:\n        print(1-p)\n    else:\n        print(p)\n    return\ndef B():\n    N, K = map(int, input().split())\n    h = LI()\n    count = 0\n    for i in h:\n        if i >= K:\n            count += 1\n        else:\n            continue\n    print(count)\n    return\ndef C():\n    N = II()\n    A = LI()\n    J = [0] * N\n    for i, n in enumerate(A):\n        J[n-1] = i+1\n    for s in J:\n        print(s, end=\" \")\n    return\ndef D():\n    A, B = map(int, input().split())\n    g = gcd(A, B)\n    go = g\n    myset = set([1])\n    sq = int(sqrt(g)) + 2\n    ans = 1\n    for i in range(2, sq):\n        if g % i == 0:\n            ans++\n        while g % i == 0:\n            g /= i\n            myset.add(i)\n        if g == 1:\n            break\n        if i == sq - 1:\n            myset.add(go)\n            ans++\n    print(ans)\n    return\ndef E():\n    N, M = LI()\n    price = [-1] * N\n    ans = [0]*N\n    for i in range(M):\n        a, b = LI()\n        c = LI()\n        for k in c:\n            if price[k-1] > a/b or price[k-1] == -1:\n                price[k-1] = a/b\n                ans[i] = a\n    if -1 in price:\n        print(-1)\n    else:\n        print(sum(price))\n    return\ndef F():\n    return\nif __name__ == '__main__':\n    D()",
        "submission_id": "s567918226",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 105
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02655",
        "code_tokens": "import sys\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfrom itertools import accumulate\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n    def unite(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n    def get_size(self, x):\n        return -self.table[self._root(x)]\ndef solve():\n    n, m = map(int, sys.stdin.buffer.readline().split())\n    extra_durabilities = [0] * n\n    self_loop_durabilities = [[] for _ in range(n)]\n    outdegrees = [0] * n\n    base_operation_count = 0\n    uft = UnionFind(n)\n    mp = map(int, sys.stdin.buffer.read().split())\n    for a, b, c in zip(mp, mp, mp):\n        a -= 1\n        b -= 1\n        outdegrees[a] += 1\n        if a == b:\n            if c >= 2:\n                self_loop_durabilities[a].append(c)\n            continue\n        uft.unite(a, b)\n        extra_durabilities[a] += c - 1\n        base_operation_count += 1\n    components = defaultdict(lambda: [0, 0, 0, []])\n    for i in range(n):\n        r = uft._root(i)\n        item = components[r]\n        item[0] += 1\n        item[1] = max(item[1], outdegrees[i])\n        item[2] += extra_durabilities[i]\n        item[3].extend(self_loop_durabilities[i])\n    exists_initial_catalyst = False\n    supplied_catalyst = 0\n    demanded_catalyst = 0\n    self_loop_catalysts_cost1 = []\n    self_loop_catalysts_cost2 = []\n    for i, (cnt, deg, dur, sel) in components.items():\n        if cnt == 1:\n            if deg == 1:\n                self_loop_catalysts_cost2.extend(c - 2 for c in sel)\n            else:\n                self_loop_catalysts_cost1.extend(c - 1 for c in sel)\n            continue\n        if deg == 1:\n            supplied_catalyst += dur\n            demanded_catalyst += 1\n        else:\n            supplied_catalyst += dur\n            if dur >= 1:\n                exists_initial_catalyst = True\n        self_loop_catalysts_cost1.extend(c - 1 for c in sel)\n    if demanded_catalyst == 0:\n        return base_operation_count\n    if not exists_initial_catalyst:\n        return -1\n    if supplied_catalyst >= demanded_catalyst:\n        return base_operation_count + demanded_catalyst\n    self_loop_catalysts_cost1.sort(reverse=True)\n    self_loop_catalysts_cost2.sort(reverse=True)\n    acc1 = list(accumulate(self_loop_catalysts_cost1))\n    acc2 = [0] + list(accumulate(self_loop_catalysts_cost2))\n    shortage = demanded_catalyst - supplied_catalyst\n    if acc1[-1] + acc2[-1] < shortage:\n        return -1\n    cost = 10 ** 18\n    for use1, cat in enumerate(acc1, start=1):\n        remaining = shortage - cat\n        if remaining <= 0:\n            cost = min(cost, use1)\n            break\n        if remaining > acc2[-1]:\n            continue\n        use2 = bisect_left(acc2, remaining)\n        cost = min(cost, use1 + 2 * use2)\n    return base_operation_count + demanded_catalyst + cost\nprint(solve())",
        "submission_id": "s121359241",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 105
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02838",
        "code_tokens": "using namespace std;\nusing ll = long long;\nstruct ModInt {\n  using M = ModInt;\n  long long v;\n  ModInt(long long _v = 0) : v(_v % MOD + MOD) { norm(); }\n  M& norm() {\n    v = (v < MOD) ? v : v - MOD;\n    return *this;\n  }\n  M operator+(const M& x) const { return M(v + x.v); }\n  M operator-(const M& x) const { return M(v + MOD - x.v); }\n  M operator*(const M& x) const { return M(v * x.v % MOD); }\n  M operator/(const M& x) const { return M(v * x.inv().v); }\n  M& operator+=(const M& x) { return *this = *this + x; }\n  M& operator-=(const M& x) { return *this = *this - x; }\n  M& operator*=(const M& x) { return *this = *this * x; }\n  M& operator/=(const M& x) { return *this = *this / x; }\n  friend istream& operator>>(istream& input, M& x) {\n    return input >> x.v, x.norm(), input;\n  }\n  friend ostream& operator<<(ostream& output, const M& x) {\n    return output << x.v;\n  }\n  M pow(long long n) const {\n    M x(v), res(1);\n    while (n) {\n      if (n & 1) res *= x;\n      x *= x;\n      n >>= 1;\n    }\n    return res;\n  }\n  M inv() const { return this->pow(MOD - 2); }\n  // M inv() const {\n  //   int x, y;\n  //   extgcd(this->v, MOD, x, y);\n  //   return *this + M(x);\n  // }\n  static long long MOD;\n  static vector<M> fact, finv;\n  static void build(int n) {\n    fact.assign(n + 1, 1);\n    for (int i = 1; i < n + 1; i++) fact[i] = fact[i - 1] * M(i);\n    finv.assign(n + 1, fact[n].inv());\n    for (int i = n; i > 0; i--) finv[i - 1] = finv[i] * M(i);\n  }\n  static M comb(int n, int k) {\n    if (n < k || k < 0) return M(0);\n    return fact[n] * finv[n - k] * finv[k];\n  }\n  static M extgcd(int a, int b, int* x, int* y) {\n    M d(a);\n    if (b) {\n      d = extgcd(b, a % b, y, x);\n      *y -= (a / b) * *x;\n    } else {\n      *x = 1, *y = 0;\n    }\n    return d;\n  }\n};\nvector<ModInt> ModInt::fact = vector<ModInt>();\nvector<ModInt> ModInt::finv = vector<ModInt>();\nlong long ModInt::MOD = 1e9 + 7;\nint main() {\n  int n;\n  cin >> n;\n  vector<ll> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<vector<int>> o(120, vector<int>(n + 1, 0));\n  vector<vector<int>> x(120, vector<int>(n + 1, 0));\n  for (int b = 0; b < 120; b++) {\n    for (int i = 0; i < n; i++) {\n      o[b][i + 1] += o[b][i];\n      x[b][i + 1] += x[b][i];\n      if (a[i] >> min(60, b) & 1) {\n        o[b][i + 1]++;\n      } else {\n        x[b][i + 1]++;\n      }\n    }\n  }\n  vector<ll> v(120);\n  ll nxt = 0;\n  for (int b = 0; b < 120; b++) {\n    ll c = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] >> min(60, b) & 1) {\n        c += x[b][i];\n      } else {\n        c += o[b][i];\n      }\n    }\n    v[b] = (nxt + c) % 2;\n    nxt = (nxt + c) / 2;\n  }\n  ModInt ans = 0;\n  for (int b = 119; b >= 0; b--) {\n    ans *= 2;\n    ans += v[b];\n  }\n  cout << ans << endl;\n}",
        "submission_id": "s134100366",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 106
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02269",
        "code_tokens": "import sys\nNoVal = -1\nBlack = 0\nRed = 1\nclass Node:\n    def __init__(self, pnode, color, value):\n        self.P = pnode \n        self.V = value \n        self.C = color \n        self.L = NoVal \n        self.R = NoVal \ndef Find(r,value):\n    if value == r.V:\n        return True\n    if value < r.V: \n        if isinstance(r.L, Node) == True:\n            return Find(r.L, value)\n    elif value > r.V: \n        if isinstance(r.R, Node) == True:\n            return Find(r.R, value)\n    return False\ndef Insert(r, value):\n    if isinstance(r, Node) == False: \n        return Node(NoVal, Black, value) \n    if value == r.V: \n        return NoVal\n    if value < r.V: \n        if isinstance(r.L, Node) == False: \n            r.L = Node(r, Red, value) \n            return r.L\n        else:\n            Insert(r.L, value) \n    elif value > r.V: \n        if isinstance(r.R, Node) == False: \n            r.R = Node(r, Red, value) \n            return r.R\n        else:\n            Insert(r.R, value) \ndef RotateR(a):\n    b = a.L     \n    b.P = a.P   \n    a.P = b     \n    a.L = b.R   \n    a.L.P = a   \n    b.R = a     \n    if b.P != NoVal: \n       if b.P.L == a: \n            b.P.L = b    \n       elif b.P.R == a: \n            b.P.R = b    \n    return b\ndef RotateL(a):\n    b = a.R     \n    b.P = a.P   \n    a.P = b     \n    a.R = b.L   \n    a.R.P = a   \n    b.L = a     \n    if b.P != NoVal: \n       if b.P.L == a: \n            b.P.L = b    \n       elif b.P.R == a: \n            b.P.R = b    \n    return b\ndef Restruct(r):\n    if isinstance(r, Node) == False: \n        return\n    if r.C == Black: \n        return\n    p = r.P\n    if p == NoVal: \n        r.C = Black \n        return\n    if p.C == Red: \n        if p.P.L == p: \n            if p.L == r: \n                p = RotateR(p) \n            else: \n                RotateL(r) \n                p = RotateR(p) \n        else: \n            if r.P.L == r: \n                RotateR(r) \n                p = RotateL(p) \n            else: \n                p = RotateL(p) \n        if p.C == Red: \n            Restruct(p)\ndef main():\n    num = int(input().strip())\n    istr = sys.stdin.read()\n    cmds = list(istr.splitlines())\n    root = NoVal\n    for i in cmds:\n        if i[0] == \"i\":\n            r = Insert(root, i[7:])\n            if isinstance(root, Node) == False:\n                root = r\n        elif i[0] == \"f\":\n            ret = Find(root, i[5:])\n            if ret == True:\n                print(\"yes\")\n            else:\n                print(\"no\")\nif __name__ == '__main__':\n    main()",
        "submission_id": "s049435595",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 106
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03112",
        "code_tokens": "from collections import defaultdict, Counter\nfrom itertools import product, groupby, count, permutations, combinations\nfrom math import pi, sqrt\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right\nfrom string import ascii_lowercase\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(10000)\nINF = float(\"inf\")\nYES, Yes, yes, NO, No, no = \"YES\", \"Yes\", \"yes\", \"NO\", \"No\", \"no\"\ndy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]\ndy8, dx8 = [0, -1, 0, 1, 1, -1, -1, 1], [1, 0, -1, 0, 1, 1, -1, -1]\ndef inside(y, x, H, W):\n    return 0 <= y < H and 0 <= x < W\ndef ceil(a, b):\n    return (a + b - 1) // b\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\ndef lcm(a, b):\n    g = gcd(a, b)\n    return a / g * b\nclass BisectWrapper:\n    from typing import List\n    from bisect import bisect, bisect_left, bisect_right\n    def __init__(self):\n        pass\n    @staticmethod\n    def exist(a: List, x: int):\n        i = bisect_left(a, x)\n        if i != len(a) and a[i] == x:\n            return True\n        return False\n    @staticmethod\n    def index(a: List, x: int):\n        i = bisect_left(a, x)\n        if i != len(a) and a[i] == x:\n            return i\n        return -1\n    @staticmethod\n    def index_lt(a: List, x: int):\n        i = bisect_left(a, x)\n        if i:\n            return i - 1\n        return -1\n    @staticmethod\n    def num_lt(a: List, x: int):\n        return bisect_left(a, x)\n    @staticmethod\n    def index_lte(a: List, x: int):\n        i = bisect_right(a, x)\n        if i:\n            return i - 1\n        return -1\n    @staticmethod\n    def num_lte(a: List, x: int):\n        return bisect_right(a, x)\n    @staticmethod\n    def index_gt(a: List, x: int):\n        i = bisect_right(a, x)\n        if i != len(a):\n            return i\n        return -1\n    @staticmethod\n    def num_gt(a: List, x: int):\n        return len(a) - bisect_right(a, x)\n    @staticmethod\n    def index_gte(a: List, x: int):\n        i = bisect_left(a, x)\n        if i != len(a):\n            return i\n        return -1\n    @staticmethod\n    def num_gte(a: List, x: int):\n        return len(a) - bisect_left(a, x)\ndef main():\n    A, B, Q = map(int, input().split())\n    S = list(sorted([int(input()) for _ in range(A)]))\n    T = list(sorted([int(input()) for _ in range(B)]))\n    for _ in range(Q):\n        x = int(input())\n        s_l = BisectWrapper.index_lte(S, x)\n        s_r = BisectWrapper.index_gte(S, x)\n        t_l = BisectWrapper.index_lte(T, x)\n        t_r = BisectWrapper.index_gte(T, x)\n        ans = INF\n        if s_l != -1:\n            if t_l != -1:\n                s, t = S[s_l], T[t_l]\n                ans = min(ans, abs(x - s) + abs(s - t))\n                ans = min(ans, abs(x - t) + abs(t - s))\n            if t_r != -1:\n                s, t = S[s_l], T[t_r]\n                ans = min(ans, abs(x - s) + abs(s - t))\n                ans = min(ans, abs(x - t) + abs(t - s))\n        elif s_r != -1:\n            if t_l != -1:\n                s, t = S[s_r], T[t_l]\n                ans = min(ans, abs(x - s) + abs(s - t))\n                ans = min(ans, abs(x - t) + abs(t - s))\n            if t_r != -1:\n                s, t = S[s_r], T[t_r]\n                ans = min(ans, abs(x - s) + abs(s - t))\n                ans = min(ans, abs(x - t) + abs(t - s))\n        print(ans)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s250700436",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 109
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02666",
        "code_tokens": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor, cos, radians, pi, sin\nfrom operator import mul\nfrom functools import reduce\nfrom operator import mul\nfrom functools import lru_cache\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n@lru_cache(maxsize=None)\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return (n*factorial(n-1)) % MOD\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n        self.size = [1] * n\n        self.group_num = n\n    def root(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.root(self.table[x])\n            return self.table[x]\n    def get_size(self, x):\n        r = self.root(x)\n        return self.size[r]\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n    def union(self, x, y):\n        r1 = self.root(x)\n        r2 = self.root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.size[r1] += self.size[r2]\n            if d1 == d2:\n                self.table[r1] -= 1\n        else:\n            self.table[r1] = r2\n            self.size[r2] += self.size[r1]\n        self.group_num -= 1\nn = I()\nP = LI()\nfac = [1] * (n + 1)\ninv = [1] * (n + 1)\nfor j in range(1, n + 1):\n    fac[j] = fac[j-1] * j % mod\ninv[n] = pow(fac[n], mod-2, mod)\nfor j in range(n-1, -1, -1):\n    inv[j] = inv[j+1] * (j+1) % mod\ndef comb(n, r):\n    if r > n or n < 0 or r < 0:\n        return 0\n    return fac[n] * inv[n - r] * inv[r] % mod\nU = UnionFind(n)\nfor i in range(n):\n    if P[i] != -1:\n        U.union(P[i] - 1, i)\nk = 0\nL = []\nfor j in range(n):\n    if P[j] == -1:\n        L += [U.size[j]]\n        k += 1\ndp = [0]*(k+1)\ndp[0] = 1\ndp_new = dp[:]\nfor i in range(1, k+1):\n    for j in range(i):\n        dp_new[j+1] += dp[j]*L[i-1]\n    dp = dp_new[:]\nif k:\n    dp[1] = sum(L) - len(L)\ncycle_count = 0\nfor i in range(1, k + 1):\n    buf = dp[i] * factorial(i - 1)\n    buf %= mod\n    buf *= pow(n - 1, k - i, mod)\n    buf %= mod\n    cycle_count += buf\ncycle_count += (U.group_num - k) * pow(n - 1, k, mod)\nans = n * pow(n - 1, k, mod)\nans %= mod\nans = ans - cycle_count\nans %= mod\nprint(ans)",
        "submission_id": "s320644857",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 110
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02749",
        "code_tokens": "from collections import deque\nn = int(input())\ninfo = [list(map(int, input().split())) for i in range(n - 1)]\ntree = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\nroot = 0\nvisited = [-1] * n\ndef dfs(root):\n    q = deque([root])\n    visited[root] = 0\n    while q:\n        v = q.pop()\n        for nxt_v in tree[v]:\n            if visited[nxt_v] != -1:\n                continue\n            else:\n                visited[nxt_v] = (visited[v] + 1) % 2\n                q.append(nxt_v)\ndfs(0)\ncnt0 = 0\ncnt1 = 0\nfor i in range(n):\n    if visited[i] == 0:\n        cnt0 += 1\n    else:\n        cnt1 += 1\nnum1 = n // 3 \nnum2 = n // 3\nnum3 = n // 3\nif n % 3 >= 1:\n   num1 += 1\nif n % 3 >= 2:\n   num2 += 1\nans = [0] * n\nset1 = set()\nset2 = set()\nset3 = set()\nfor i in range(1, n + 1):\n    if i % 3 == 0:\n        set3.add(i)\n    elif i % 3 == 1:\n        set1.add(i)\n    elif i % 3 == 2:\n        set2.add(i)\nif cnt0 <= num3:\n    for i in range(n):\n        if visited[i] == 0:\n            ans[i] = pop.set3()\n        else:\n            if set1:\n                ans[i] = pop.set1() \n            elif set2:\n                ans[i] = pop.set2()         \n            elif set3:\n                ans[i] = pop.set3()  \nelif cnt1 <= num3:\n    for i in range(n):\n        if visited[i] == 1:\n            ans[i] = pop.set3()\n        else:\n            if set1:\n                ans[i] = pop.set1() \n            elif set2:\n                ans[i] = pop.set2()         \n            elif set3:\n                ans[i] = pop.set3()  \nelse:\n    num147 = 0\n    num258 = 0\n    num369 = 0\n    for i in range(n):\n        if visited[i] == 0:\n            num = num147 * 3 + 1\n            if num > n:\n                num = num369 * 3 + 3\n                ans[i] = num\n                if num > n:\n                    print(-1)\n                    exit()\n                set3.remove(num)\n                num369 += 1\n                continue\n            ans[i] = num \n            set1.remove(num)\n            num147 += 1\n        else:\n            num = num258 * 3 + 2 \n            if num > n:\n                num = num369 * 3 + 3\n                if num > n:\n                    print(-1)\n                    exit()\n                ans[i] = num\n                set3.remove(num)\n                num369 += 1\n                continue\n            ans[i] = num \n            set2.remove(num)\n            num258 += 1\n    for i in range(n):\n        if ans[i] == 0:\n            if set1:\n                ans[i] = set1.pop()\n            elif set2:\n                ans[i] = set2.pop()\n            elif set3:\n                ans[i] = set3.pop()\nprint(*ans)",
        "submission_id": "s426578824",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 113
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03186",
        "code_tokens": "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\nMOD = 10**9+7\nINF = float('inf')\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\ndef DD(arg): return defaultdict(arg)\ndef inv(n): return pow(n, MOD-2, MOD)\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n):\n    return kaijo_memo[n]\n  if(len(kaijo_memo) == 0):\n    kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n):\n    kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n):\n    return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0):\n    gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n):\n    gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\ndef nCr(n,r):\n  if(n == r):\n    return 1\n  if(n < r or r < 0):\n    return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1:\n    arr.append([temp, 1])\n  if arr==[]:\n    arr.append([n, 1])\n  return arr\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  return divisors\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\ndef lcm(a, b):\n    return a * b // gcd (a, b)\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n -1\n    count += 1\n  return count\ndef base_10_to_n(X, n):\n  if X//n:\n    return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\nA,B,C = IL()\nprint(B+min(C,min(A+B-1)))",
        "submission_id": "s351881603",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 114
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03162",
        "code_tokens": "from math import log2, log, ceil\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b%a, a)\ndef nCr(n, k): \n    if(k > n - k): \n        k = n - k \n    res = 1\n    for i in range(k): \n        res = res * (n - i) \n        res = res / (i + 1) \n    return res \ndef upper_bound(a, x, lo=0):\n    hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x:\n            lo = mid+1\n        else:\n            hi = mid\n    return lo\ndef primefs(n):\n    primes = {}\n    while(n%2 == 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    return primes\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\nMAXN = int(1e6 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\ndef factoriazation(x):\n    ret = {};\n    while x != 1:\n        ret[spf[x]] = ret.get(spf[x], 0) + 1;\n        x = x//spf[x]\n    return ret\ndef int_array():\n    return list(map(int, input().strip().split()))\ndef str_array():\n    return input().strip().split();\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\nn = int(input());\nxx,yy,zz = 0,0,0;\nfor _ in range(n):\n    a,b,c = int_array();\n    x = a + max(yy, zz);\n    y = b + max(xx, zz);\n    z = c + max(xx, yy);\n    xx, yy, zz = x, y, z;\nprint(max(xx, yy, zz));",
        "submission_id": "s171354964",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 114
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03676",
        "code_tokens": "from collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\nsys.setrecursionlimit(1000000)\nmod = 1000000007\ndef A():\n    n,k = LI()\n    a = LI()\n    d = defaultdict(lambda:0)\n    for i in a:\n        d[i] += 1\n    d = list(d.values())\n    d.sort()\n    ans = 0\n    for i in range(len(d)-k):\n        ans += d[i]\n    print(ans)\n    return\ndef B():\n    n,z,w = LI()\n    a = LI()\n    if n == 1:\n        print(abs(a[0]-w))\n        return\n    ans = max(abs(a[-1]-w),abs(a[-2]-a[-1]))\n    print(ans)\n    return\ndef C():\n    n = I()\n    s1 = S()\n    s2 = S()\n    dp = [[[0]*3 for j in range(3)] for i in range(n+1)]\n    if s1[0] == s2[0]:\n        dp[1] = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n    else:\n        dp[1] = [[0 if i == j else 1 for j in range(3)] for i in range(3)]\n    for i in range(1,n):\n        ni = i+1\n        if s1[i] == s2[i]:\n            for j in range(3):\n                for k in range(3):\n                    if k == j:continue\n                    for l in range(3):\n                        if l == j:continue\n                        dp[ni][j][j] += dp[i][k][l]\n        else:\n            if i and s1[i] == s1[i-1]:\n                for j in range(3):\n                    for k in range(3):\n                        dp[ni][j][k] = dp[i][j][k]\n            else:\n                for j in range(3):\n                    for k in range(3):\n                        if k == j:continue\n                        for l in range(3):\n                            if l == j:continue\n                            for m in range(3):\n                                if m == k:continue\n                                dp[ni][j][k] += dp[i][l][m]\n    ans = 0\n    for i in range(3):\n        for j in range(3):\n            ans += dp[n][i][j]\n    print(ans%mod)\n    return\ndef D():\n    def comb(a,b):\n        return fact[a]*inv[b]*inv[a-b]%mod\n    n = I()\n    a = LI()\n    d = defaultdict(lambda : 0)\n    for i in range(n+1):\n        if d[a[i]]:\n            l = d[a[i]]-1\n            r = n-i\n            break\n        d[a[i]] = i+1\n    fact = [1]\n    m = 100000\n    for i in range(m):\n        fact.append(fact[-1]*(i+1)%mod)\n    inv = [1]*(m+1)\n    inv[m] = pow(fact[m],mod-2,mod)\n    for i in range(m)[::-1]:\n        inv[i] = inv[i+1]*(i+1)%mod\n    for i in range(1,n+2):\n        ans = comb(n+1,i)\n        if l+r >= i-1:\n            ans -= comb(l+r,i-1)\n            ans %= mod\n        print(ans)\n    return\ndef E():\n    return\nif __name__ == \"__main__\":\n    D()",
        "submission_id": "s051693096",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 115
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02269",
        "code_tokens": "N = int(input())\nA = [input() for i in range(N)]\nM = 10465270\nT = []\nN = int(input())\nA = [input() for i in range(N)]\nM = N * 10\nT = [0 for i in range(M)]\ndef convert_str_to_int(s):\n    if s == \"A\":\n        return 1\n    elif s == \"C\":\n        return 2\n    elif s == \"G\":\n        return 3\n    elif s == \"T\":\n        return 4\n    else:\n        return 0\ndef get_key(value: str) -> int:\n    converted_value = \"\"\n    for s in value:\n        i = convert_str_to_int(s)\n        converted_value += str(i)\n    return int(converted_value)\ndef h1(key: int) -> int:\n    return key % M\ndef h2(key: int) -> int:\n    move_value = 1 + (key % (M-1))\n    return move_value\ndef h(key:int, i:int) -> int:\n    hash_value = (h1(key) + i+h2(key)) % M\n    return hash_value\ndef find(key: int) -> bool:\n    i = 0\n    while True:\n        j = h(key, i)\n        if T[j] == key:\n            return True\n        elif T[j] == 0 or i >= M:\n            return False\n        else:\n            i += 1\ndef insert(key: int) -> None:\n    i = 0\n    while True:\n        j = h(key, i)\n        if T[j] == 0:\n            T[j] = key\n            return\n        else:\n            i += 1\nfor row in A:\n    order, value = row.split()\n    key = get_key(value)\n    if order[0] == \"i\":\n        insert(key)\n    else:\n        if find(key):\n            print(\"yes\")\n        else:\n            print(\"no\")\ndef convert_str_to_int(s):\n    if s == \"A\":\n        return 1\n    elif s == \"C\":\n        return 2\n    elif s == \"G\":\n        return 3\n    elif s == \"T\":\n        return 4\n    else:\n        return 0\ndef get_key(value: str) -> int:\n    converted_value = \"\"\n    for s in value:\n        i = convert_str_to_int(s)\n        converted_value += str(i)\n    return int(converted_value)\ndef h1(key: int) -> int:\n    return key % M\ndef h2(key: int) -> int:\n    move_value = 1 + (key % (M-1))\n    return move_value\ndef h(key:int, i:int) -> int:\n    hash_value = (h1(key) + i+h2(key)) % M\n    return hash_value\ndef find(key: int) -> bool:\n    i = 0\n    while True:\n        j = h(key, i)\n        if T[j] == key:\n            return True\n        elif T[j] == 0 or i >= M:\n            return False\n        else:\n            i += 1\ndef insert(key: int) -> None:\n    i = 0\n    while True:\n        j = h(key, i)\n        if T[j] == 0:\n            T[j] = key\n            return\n        else:\n            i += 1\nfor row in A:\n    order, value = row.split()\n    key = get_key(value)\n    if order[0] == \"i\":\n        insert(key)\n    else:\n        if find(key):\n            print(\"yes\")\n        else:\n            print(\"no\")",
        "submission_id": "s742960632",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 116
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03634",
        "code_tokens": "import heapq\nclass Graph:\n    def __init__(self,v,edgelist,w_v = None,directed = False):\n        super().__init__()\n        self.v = v\n        self.w_e = [{} for _ in [0]*self.v]\n        self.neighbor = [[] for _ in [0]*self.v]\n        self.w_v = w_v\n        self.directed = directed\n        for i,j,w in edgelist:\n            self.w_e[i][j] = w\n            self.neighbor[i].append(j)\n    def dijkstra(self,v_n):\n        d = [float('inf')]*self.v\n        d[v_n] = 0\n        prev = [-1]*self.v\n        queue = []\n        for i,d_i in enumerate(d): heapq.heappush(queue,(d_i,i))\n        while len(queue)>0:\n            d_u,u = queue.pop()\n            if d[u]<d_u :continue\n            for v in self.neighbor[u]:\n                alt = d[u]+self.w_e[u][v]\n                if d[v]>alt:\n                    d[v] = alt\n                    prev[v] = u\n                    heapq.heappush(queue,(alt,v))\n        return d,prev\n    def warshallFloyd(self):\n        d = [[10**18]*self.v for _ in [0]*self.v]\n        for i in range(self.v):\n            d[i][i] = 0\n        for i in range(self.v):\n            for j in self.neighbor[i]:\n                d[i][j] = self.w_e[i][j]\n        for i in range(self.v):\n            for j in self.neighbor[i]:\n                d[i][j] = self.w_e[i][j]\n        for k in range(self.v):\n            for i in range(self.v):\n                for j in range(self.v):\n                    check = d[i][k] + d[k][j]\n                    if d[i][j] > check:\n                        d[i][j] = check\n        return d\n    def prim(self):\n        gb = GraphBuilder(self.v,self.directed)\n        queue = []\n        for i,w in self.w_e[0].items(): heapq.heappush(queue,(w,0,i))\n        rest = [True]*self.v\n        rest[0] = False\n        v = 1\n        while len(queue)>0:\n            w,i,j = heapq.heappop(queue)\n            if rest[j]:\n                gb.addEdge(i,j,w)\n                rest[j] = False\n                for k,w in self.w_e[j].items():\n                    if rest[k]:heapq.heappush(queue,(w,j,k))\n        return gb\nclass Tree():\n    def __init__(self,v,e):\n        pass\nclass GraphBuilder():\n    def __init__(self,v,directed = False):\n        self.v = v\n        self.directed = directed\n        self.edge = []\n    def addEdge(self,i,j,w=1):\n        if not self.directed:\n            self.edge.append((j,i,w))\n        self.edge.append((i,j,w))\n    def addEdges(self,edgelist,weight = True):\n        if weight:\n            if self.directed:\n                for i,j,w in edgelist:\n                    self.edge.append((i,j,w))\n            else:\n                for i,j,w in edgelist:\n                    self.edge.append((i,j,w))\n                    self.edge.append((j,i,w))\n        else:\n            if self.directed:\n                for i,j,w in edgelist:\n                    self.edge.append((i,j,1))\n            else:\n                for i,j,w in edgelist:\n                    self.edge.append((i,j,1))\n                    self.edge.append((j,i,1))\n    def addAdjMat(self, mat):\n        for i,mat_i in enumerate(mat):\n            for j,w in enumerate(mat_i):\n                self.edge.append((i,j,w))\n    def buildTree(self):\n        pass\n    def buildGraph(self):\n        return Graph(self.v,self.edge,directed=self.directed)\ndef main():\n    n = int(input())\n    edge = []\n    for _ in range(n):\n        a,b,w = tuple([int(t)for t in input().split()])\n        edge.append((a-1,b-1,w))\n    gb = GraphBuilder(n)\n    gb.addEdges(edge)\n    g = gb.buildGraph()\n    q,k = tuple([int(t)for t in input().split()])\n    dijk = g.dijkstra(k-1)[0]\n    ans = []\n    for _ in range(q):\n        x,y = tuple([int(t)-1 for t in input().split()])\n        ans.append(dijk[x]+dijk[y])\n    for a_i in ans:\n        print(a_i)\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s029640465",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 116
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03245",
        "code_tokens": "from collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\nimport itertools\nsys.setrecursionlimit(10**5)\nstdin = sys.stdin\nbisect_left = bisect.bisect_left\nbisect_right = bisect.bisect_right\ndef LI(): return list(map(int, stdin.readline().split()))\ndef LF(): return list(map(float, stdin.readline().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef II(): return int(stdin.readline())\ndef IF(): return float(stdin.readline())\ndef LS(): return list(map(list, stdin.readline().split()))\ndef S(): return list(stdin.readline().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\ndef A():\n    n = S()\n    for i in n:\n        if i == \"1\":\n            print(9, end=\"\")\n        else:\n            print(1, end=\"\")\n    print()\n    return\ndef B():\n    n = II()\n    for i in range(111, 1000, 111):\n        if n <= i:\n            print(i)\n            return\n    return\ndef C():\n    return\ndef D():\n    n = II()\n    xy = LIR(n)\n    xy_ = [a + b for a, b in xy]\n    RULD = [\"R\", \"U\", \"L\", \"D\"]\n    R = 0\n    if len(set(map(lambda x: x & 1, xy_))) == 2:\n        print(-1)\n        return\n    ans = [1 << i for i in range(39)]\n    f = (xy[0][0] + xy[0][1]) & 1 ^ 1\n    if f: ans = [1] + ans\n    xy = [[abs(x - f), abs(y), ((x + f) < 0) << 0 | (y < 0) << 1] for x, y in xy]\n    lis = []\n    for x, y, p in xy:\n        b = (x & 1) ^ 1\n        tmp = [b]\n        for i in range(1,38):\n            if b == R:\n                if x >> i & 1:\n                    if y >> i & 1:\n                        k = i\n                        while x >> k & 1:\n                            x ^= 1 << k\n                            k += 1\n                        x ^= 1 << k\n                        tmp[-1] ^= 2\n                        b ^= 1\n                        tmp.append(b)\n                    else:\n                        tmp.append(b)\n                else:\n                    if y >> i & 1:\n                        b ^= 1\n                        tmp.append(b)\n                    else:\n                        tmp[-1] ^= 2\n                        tmp.append(b)\n            else:\n                if y >> i & 1:\n                    if x >> i & 1:\n                        k = i\n                        while y >> k & 1:\n                            y ^= 1 << k\n                            k += 1\n                        y ^= 1 << k\n                        tmp[-1] ^= 2\n                        b ^= 1\n                        tmp.append(b)\n                    else:\n                        tmp.append(b)\n                else:\n                    if x >> i & 1:\n                        b ^= 1\n                        tmp.append(b)\n                    else:\n                        tmp[-1] ^= 2\n                        tmp.append(b)\n        for i in range(39):\n            if p & 1:\n                if tmp[i] & 1 ^ 1:\n                    tmp[i] ^= 2\n            if p & 2:\n                if tmp[i] & 1:\n                    tmp[i] ^= 2\n        lis.append(map(lambda x: RULD[x], tmp))\n    print(39+f)\n    print(*ans)\n    for a in lis:\n        print(\"R\"*f+\"\".join(a))\n    return\nif __name__ == '__main__':\n    D()",
        "submission_id": "s821558438",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 119
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03045",
        "code_tokens": "from sys import stdout\nfrom bisect import bisect_left as binl\nfrom copy import copy, deepcopy\nfrom collections import defaultdict\nmod = 1\ndef intin():\n    input_tuple = input().split()\n    if len(input_tuple) <= 1:\n        return int(input_tuple[0])\n    return tuple(map(int, input_tuple))\ndef intina():\n    return [int(i) for i in input().split()]\ndef intinl(count):\n    return [intin() for _ in range(count)]\ndef modadd(x, y):\n    global mod\n    return (x + y) % mod\ndef modmlt(x, y):\n    global mod\n    return (x * y) % mod\ndef lcm(x, y):\n    while y != 0:\n        z = x % y\n        x = y\n        y = z\n    return x\ndef combination(x, y):\n    assert(x >= y)\n    if y > x // 2:\n        y = x - y\n    ret = 1\n    for i in range(0, y):\n        j = x - i\n        i = i + 1\n        ret = ret * j\n        ret = ret // i\n    return ret\ndef get_divisors(x):\n    retlist = []\n    for i in range(1, int(x**0.5) + 3):\n        if x % i == 0:\n            retlist.append(i)\n            retlist.append(x // i)\n    return retlist\ndef get_factors(x):\n    retlist = []\n    for i in range(2, int(x**0.5) + 3):\n        while x % i == 0:\n            retlist.append(i)\n            x = x // i\n    retlist.append(x)\n    return retlist\ndef make_linklist(xylist):\n    linklist = {}\n    for a, b in xylist:\n        linklist.setdefault(a, [])\n        linklist.setdefault(b, [])\n        linklist[a].append(b)\n        linklist[b].append(a)\n    return linklist\ndef calc_longest_distance(linklist, v=1):\n    distance_list = {}\n    distance_count = 0\n    distance = 0\n    vlist_previous = []\n    vlist = [v]\n    nodecount = len(linklist)\n    while distance_count < nodecount:\n        vlist_next = []\n        for v in vlist:\n            distance_list[v] = distance\n            distance_count += 1\n            vlist_next.extend(linklist[v])\n        distance += 1\n        vlist_to_del = vlist_previous\n        vlist_previous = vlist\n        vlist = list(set(vlist_next) - set(vlist_to_del))\n    max_distance = -1\n    max_v = None\n    for v, distance in distance_list.items():\n        if distance > max_distance:\n            max_distance = distance\n            max_v = v\n    return (max_distance, max_v)\ndef calc_tree_diameter(linklist, v=1):\n    _, u = calc_longest_distance(linklist, v)\n    distance, _ = calc_longest_distance(linklist, u)\n    return distance\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n    def root(self, i):\n        if (self.parent[i] == i):\n            return i\n        self.parent[i] = self.root(self.parent[i])\n        return self.parent[i]\n    def unite(self, i, j):\n        rooti = self.root(i)\n        rootj = self.root(j)\n        if rooti == rootj:\n            return\n        if i < j:\n            self.parent[rootj] = rooti\n        else:\n            self.parent[rooti] = rootj\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\ndef main():\n    n, m = intin()\n    xyzlist = intinl(m)\n    u = UnionFind(n)\n    for x, y, z in xyzlist:\n        u.unite(x - 1, y - 1)\n    ansset = set()\n    for i in range(n):\n        ansset.add(u.root(i))\n    print(len(ansset))\nif __name__ == '__main__':\n    main()",
        "submission_id": "s990143275",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 119
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02900",
        "code_tokens": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys\nimport random\nimport itertools\nimport math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return list(map(list, input().split()))\ndef S(): return list(input().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\ndef gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\ndef my_index_multi(l, x):\n    return [i for i, _x in enumerate(l) if _x == x]\nmod = 1000000007\ninf = float('INF')\ndef A():\n    a = II()\n    b = a//2\n    p = b/a\n    if a % 2:\n        print(1-p)\n    else:\n        print(p)\n    return\ndef B():\n    N, K = map(int, input().split())\n    h = LI()\n    count = 0\n    for i in h:\n        if i >= K:\n            count += 1\n        else:\n            continue\n    print(count)\n    return\ndef C():\n    N = II()\n    A = LI()\n    J = [0] * N\n    for i, n in enumerate(A):\n        J[n-1] = i+1\n    for s in J:\n        print(s, end=\" \")\n    return\ndef D():\n    A, B = map(int, input().split())\n    g = gcd(A, B)\n    sq = int(sqrt(g)) + 1\n    ans = 1\n    for i in range(2, sq):\n        if g % i == 0:\n            ans += 1\n        while g % i == 0:\n            g /= i\n        if g == 1:\n            break\n        if i == sq - 1:\n            ans += 1\n    print(ans)\n    return\ndef E():\n    N, M = LI()\n    bit_max = 1 << N\n    dp = [[inf for i in range(bit_max)] for j in range(M+1)]\n    dp[0][0] = 0\n    for i in range(M):\n        a, b = LI()\n        c = LI()\n        bit = 0\n        for d in c:\n            bit += 1 << (d-1)\n        for w in range(bit_max):\n            t = w | bit\n            cost = dp[i][w] + a\n            dp[i+1][t] = min(dp[i+1][t], cost)\n            dp[i+1][w] = min(dp[i][w], dp[i+1][w])\n    print(-1) if dp[-1][-1] == inf else print(dp[-1][-1])\n    return\ndef F():\n    S = input()\n    print(solution(S))\ndef solution(S):\n    import math\n    vowels = \"AIUEO\"\n    count = 0\n    consonants = 0\n    newC = []\n    newV = []\n    for i in S[:-1]:\n        if i in vowels:\n            count += 1\n            newV.append(i)\n        else:\n            consonants += 1\n            newC.append(i)\n    if consonants < count or consonants - 2 > count:\n        return 0\n    a = math.factorial(len(set(newC))) * math.factorial(len(set(newV)))\n    return a\n    pass\nif __name__ == '__main__':\n    E()",
        "submission_id": "s937094672",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 119
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03045",
        "code_tokens": "from sys import stdout\nfrom bisect import bisect_left as binl\nfrom copy import copy, deepcopy\nfrom collections import defaultdict\nmod = 1\ndef intin():\n    input_tuple = input().split()\n    if len(input_tuple) <= 1:\n        return int(input_tuple[0])\n    return tuple(map(int, input_tuple))\ndef intina():\n    return [int(i) for i in input().split()]\ndef intinl(count):\n    return [intin() for _ in range(count)]\ndef modadd(x, y):\n    global mod\n    return (x + y) % mod\ndef modmlt(x, y):\n    global mod\n    return (x * y) % mod\ndef lcm(x, y):\n    while y != 0:\n        z = x % y\n        x = y\n        y = z\n    return x\ndef combination(x, y):\n    assert(x >= y)\n    if y > x // 2:\n        y = x - y\n    ret = 1\n    for i in range(0, y):\n        j = x - i\n        i = i + 1\n        ret = ret * j\n        ret = ret // i\n    return ret\ndef get_divisors(x):\n    retlist = []\n    for i in range(1, int(x**0.5) + 3):\n        if x % i == 0:\n            retlist.append(i)\n            retlist.append(x // i)\n    return retlist\ndef get_factors(x):\n    retlist = []\n    for i in range(2, int(x**0.5) + 3):\n        while x % i == 0:\n            retlist.append(i)\n            x = x // i\n    retlist.append(x)\n    return retlist\ndef make_linklist(xylist):\n    linklist = {}\n    for a, b in xylist:\n        linklist.setdefault(a, [])\n        linklist.setdefault(b, [])\n        linklist[a].append(b)\n        linklist[b].append(a)\n    return linklist\ndef calc_longest_distance(linklist, v=1):\n    distance_list = {}\n    distance_count = 0\n    distance = 0\n    vlist_previous = []\n    vlist = [v]\n    nodecount = len(linklist)\n    while distance_count < nodecount:\n        vlist_next = []\n        for v in vlist:\n            distance_list[v] = distance\n            distance_count += 1\n            vlist_next.extend(linklist[v])\n        distance += 1\n        vlist_to_del = vlist_previous\n        vlist_previous = vlist\n        vlist = list(set(vlist_next) - set(vlist_to_del))\n    max_distance = -1\n    max_v = None\n    for v, distance in distance_list.items():\n        if distance > max_distance:\n            max_distance = distance\n            max_v = v\n    return (max_distance, max_v)\ndef calc_tree_diameter(linklist, v=1):\n    _, u = calc_longest_distance(linklist, v)\n    distance, _ = calc_longest_distance(linklist, u)\n    return distance\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n    def root(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.root(self.parent[i])\n        return self.parent[i]\n    def unite(self, i, j):\n        rooti = self.root(i)\n        rootj = self.root(j)\n        if rooti == rootj:\n            return\n        if i < j:\n            self.parent[rootj] = rooti\n        else:\n            self.parent[rooti] = rootj\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\ndef main():\n    n, m = intin()\n    xyzlist = intinl(m)\n    u = UnionFind(n)\n    for x, y, z in xyzlist:\n        u.unite(x - 1, y - 1)\n    ansset = set()\n    for i in range(n):\n        ansset.add(u.root(i))\n    return\n    print(len(ansset))\nif __name__ == '__main__':\n    main()",
        "submission_id": "s249605640",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 120
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02713",
        "code_tokens": "import math\nimport fractions\nimport bisect\nimport collections\nimport itertools\nimport heapq\nimport string\nimport sys\nimport copy\nfrom decimal import *\nfrom collections import deque\nsys.setrecursionlimit(10**7)\nMOD = 10**9+7\nINF = float('inf') \ndef gcd(a,b):return fractions.gcd(a,b) \ndef lcm(a,b):return (a*b) // fractions.gcd(a,b) \ndef iin(): return int(sys.stdin.readline()) \ndef ifn(): return float(sys.stdin.readline()) \ndef isn(): return sys.stdin.readline().split() \ndef imn(): return map(int, sys.stdin.readline().split()) \ndef imnn(): return map(lambda x:int(x)-1, sys.stdin.readline().split()) \ndef fmn(): return map(float, sys.stdin.readline().split()) \ndef iln(): return list(map(int, sys.stdin.readline().split())) \ndef iln_s(): return sorted(iln()) \ndef iln_r(): return sorted(iln(), reverse=True) \ndef fln(): return list(map(float, sys.stdin.readline().split())) \ndef join(l, s=''): return s.join(l) \ndef perm(l, n): return itertools.permutations(l, n) \ndef perm_count(n, r): return math.factorial(n) // math.factorial(n-r) \ndef comb(l, n): return itertools.combinations(l, n) \ndef comb_count(n, r): return math.factorial(n) // (math.factorial(n-r) * math.factorial(r)) \ndef two_distance(a, b, c, d): return ((c-a)**2 + (d-b)**2)**.5 \ndef m_add(a,b): return (a+b) % MOD\ndef print_list(l): print(*l, sep='\\n')\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef No(): print('No')\ndef sieves_of_e(n):\n    is_prime = [True] * (n+1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5)+1):\n        if not is_prime[i]: continue\n        for j in range(i * 2, n+1, i): is_prime[j] = False\n    return is_prime\nK = iin()\nans = 0\nfor a in range(1, K+1):\n    for b in range(1, K+1):\n        for c in range(1, K+1):\n            tmp = math.gcd(a, b)\n            tmp = math.gcd(tmp, c)\n            ans += tmp\nprint(ans)\nimport math\nimport fractions\nimport bisect\nimport collections\nimport itertools\nimport heapq\nimport string\nimport sys\nimport copy\nfrom decimal import *\nfrom collections import deque\nsys.setrecursionlimit(10**7)\nMOD = 10**9+7\nINF = float('inf') \ndef gcd(a,b):return fractions.gcd(a,b) \ndef lcm(a,b):return (a*b) // fractions.gcd(a,b) \ndef iin(): return int(sys.stdin.readline()) \ndef ifn(): return float(sys.stdin.readline()) \ndef isn(): return sys.stdin.readline().split() \ndef imn(): return map(int, sys.stdin.readline().split()) \ndef imnn(): return map(lambda x:int(x)-1, sys.stdin.readline().split()) \ndef fmn(): return map(float, sys.stdin.readline().split()) \ndef iln(): return list(map(int, sys.stdin.readline().split())) \ndef iln_s(): return sorted(iln()) \ndef iln_r(): return sorted(iln(), reverse=True) \ndef fln(): return list(map(float, sys.stdin.readline().split())) \ndef join(l, s=''): return s.join(l) \ndef perm(l, n): return itertools.permutations(l, n) \ndef perm_count(n, r): return math.factorial(n) // math.factorial(n-r) \ndef comb(l, n): return itertools.combinations(l, n) \ndef comb_count(n, r): return math.factorial(n) // (math.factorial(n-r) * math.factorial(r)) \ndef two_distance(a, b, c, d): return ((c-a)**2 + (d-b)**2)**.5 \ndef m_add(a,b): return (a+b) % MOD\ndef print_list(l): print(*l, sep='\\n')\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef No(): print('No')\ndef sieves_of_e(n):\n    is_prime = [True] * (n+1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5)+1):\n        if not is_prime[i]: continue\n        for j in range(i * 2, n+1, i): is_prime[j] = False\n    return is_prime\nK = iin()\nans = 0\nfor a in range(1, K+1):\n    for b in range(1, K+1):\n        for c in range(1, K+1):\n            if a == 1 or b == 1 or c == 1:\n                ans += 1\n            elif a == b == c:\n                ans += a\n            elif a == b:\n                ans += math.gcd(a, c)\n            elif a == c:\n                ans += math.gcd(b,c)\n            else:\n                tmp = math.gcd(a, b)\n                if tmp == 1:\n                    ans += 1\n                else:\n                    tmp = math.gcd(tmp, c)\n                    ans += tmp\nprint(ans)",
        "submission_id": "s714508854",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 122
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02749",
        "code_tokens": "def examA():\n    S = SI()\n    if len(S)%2==1:\n        print(\"No\")\n        return\n    for i in range(len(S)//2):\n        if S[i*2:i*2+2]!=\"hi\":\n            print(\"No\")\n            return\n    print(\"Yes\")\n    return\ndef examB():\n    a, b, M = LI()\n    A = LI()\n    B = LI()\n    D = [LI()for _ in range(M)]\n    ans = min(A) + min(B)\n    for x,y,c in D:\n        cur = A[x-1]+B[y-1]-c\n        ans = min(ans,cur)\n    print(ans)\n    return\ndef examC():\n    def bfs(n, e, fordfs):\n        W = [-1] * n\n        W[e] = 0\n        que = deque()\n        que.append(e)\n        while que:\n            now = que.popleft()\n            nowW = W[now]\n            for ne in fordfs[now]:\n                if W[ne] == -1:\n                    W[ne] = nowW + 1\n                    que.append(ne)\n        return W\n    N = I()\n    V = [[]for _ in range(N)]\n    for _ in range(N-1):\n        a, b = LI()\n        a -= 1\n        b -= 1\n        V[a].append(b)\n        V[b].append(a)\n    L = bfs(N,0,V)\n    odd = 0\n    for l in L:\n        if l==-1:\n            print(-1)\n            return\n        if l%2==1:\n            odd += 1\n    G = []\n    if odd*2<N:\n        for i in range(N):\n            if L[i]%2==1:\n                G.append(i)\n    else:\n        for i in range(N):\n            if L[i]%2==0:\n                G.append(i)\n    used = [False]*(N+1)\n    ans = [0]*N\n    if N//3>=len(G):\n        cur = 3\n        for g in G:\n            ans[g] = cur\n            used[cur] = True\n            cur += 3\n        cur = 1\n        for i in range(N):\n            if ans[i]!=0:\n                continue\n            while(used[cur]):\n                cur += 1\n            ans[i] = cur\n            used[cur] = True\n    else:\n        cur = 1\n        for g in G:\n            ans[g] = cur\n            used[cur] = True\n            cur += 3\n        cur = 1\n        for i in range(N):\n            if ans[i]!=0:\n                continue\n            while(used[cur]):\n                cur += 1\n            ans[i] = cur\n            used[cur] = True\n    print(\" \".join(map(str,ans)))\n    return\ndef examD():\n    ans = 0\n    print(ans)\n    return\ndef examE():\n    ans = 0\n    print(ans)\n    return\ndef examF():\n    ans = 0\n    print(ans)\n    return\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\nsys.setrecursionlimit(10**6)\nif __name__ == '__main__':\n    examC()",
        "submission_id": "s843915569",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 123
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02807",
        "code_tokens": "from heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations,combinations,groupby\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nimport random\ndef S_():\n    return input()\ndef LS():\n    return [i for i in input().split()]\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef NI(n):\n    return [int(input()) for i in range(n)]\ndef NI_(n):\n    return [int(input())-1 for i in range(n)]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef ItoS(nn):\n    return chr(nn+97)\ndef LtoS(ls):\n    return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef bit_combination(k,n=2):\n    rt=[]\n    for tb in range(n**k):\n        s=[tb//(n**bt)%n for bt in range(k)]\n        rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['Yes','No']\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\nts=time.time()\ninput=lambda: sys.stdin.readline().rstrip()\ndef ran_input():\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\nclass Comb:\n    def __init__(self,n,mo=10**9+7):\n        self.fac=[0]*(n+1)\n        self.inv=[1]*(n+1)\n        self.fac[0]=1\n        self.fact(n)\n        for i in range(1,n+1):\n            self.fac[i]=i*self.fac[i-1]%mo\n            self.inv[n]*=i\n            self.inv[n]%=mo\n        self.inv[n]=pow(self.inv[n],mo-2,mo)\n        for i in range(1,n):\n            self.inv[n-i]=self.inv[n-i+1]*(n-i+1)%mo\n        return\n    def fact(self,n):\n        return self.fac[n]\n    def invf(self,n):\n        return self.inv[n]\n    def comb(self,x,y):\n        if y<0 or y>x:\n            return 0\n        return self.fac[x]*self.inv[x-y]*self.inv[y]%mo\nshow_flg=False\nshow_flg=True\nans=0\nn=I()\nx=LI()\np=permutations(range(n-1))\ncm=Comb(n+20)\nStrN=[0]*(n+10)\nStrN[1]=1\nStrN[0]=0\ndef St(n):\n    if n==1:\n        return 1\n    if StrN[n]!=0:\n        return StrN[n]\n    else:\n        StrN[n]=(n)*St(n-1)+cm.fac[n-1]\n        return StrN[n]\nSt(n)\nPat=[0]*(n+1)\nfor i in range(n):\n    Pat[i]=StrN[i]*cm.fac[n-1]*cm.inv[i]%mo\nfor i in range(n-1):\n    ans+=(x[i+1]-x[i])*Pat[i+1]\n    ans%=mo\nprint(ans%mo)",
        "submission_id": "s244728621",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 124
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03287",
        "code_tokens": "n,m=map(int,input().split())\nA=list(map(int,input().split()))\nB=[0]\nfor i in range(n):\n  B.append((B[-1]+A[i])%m)\nC=[]\nclass TreeNode(object): \n  def __init__(self, val): \n    self.val = val \n    self.left = None\n    self.right = None\n    self.height = 1\nclass AVL_Tree(object): \n  def insert(self, root, key): \n    if not root: \n      return TreeNode(key) \n    elif key < root.val: \n      root.left = self.insert(root.left, key) \n    else: \n      root.right = self.insert(root.right, key) \n    root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) \n    balance = self.getBalance(root) \n    if balance > 1 and key < root.left.val: \n      return self.rightRotate(root) \n    if balance < -1 and key > root.right.val: \n      return self.leftRotate(root) \n    if balance > 1 and key > root.left.val: \n      root.left = self.leftRotate(root.left) \n      return self.rightRotate(root) \n    if balance < -1 and key < root.right.val: \n      root.right = self.rightRotate(root.right) \n      return self.leftRotate(root) \n    return root \n  def delete(self, root, key): \n    if not root: \n      return root \n    elif key < root.val: \n      root.left = self.delete(root.left, key) \n    elif key > root.val: \n      root.right = self.delete(root.right, key) \n    else: \n      if root.left is None: \n        temp = root.right \n        root = None\n        return temp \n      elif root.right is None: \n        temp = root.left \n        root = None\n        return temp \n      temp = self.getMinValueNode(root.right) \n      root.val = temp.val \n      root.right = self.delete(root.right, temp.val) \n    if root is None: \n      return root \n    root.height = 1 + max(self.getHeight(root.left), \n              self.getHeight(root.right)) \n    balance = self.getBalance(root) \n    if balance > 1 and self.getBalance(root.left) >= 0: \n      return self.rightRotate(root) \n    if balance < -1 and self.getBalance(root.right) <= 0: \n      return self.leftRotate(root) \n    if balance > 1 and self.getBalance(root.left) < 0: \n      root.left = self.leftRotate(root.left) \n      return self.rightRotate(root) \n    if balance < -1 and self.getBalance(root.right) > 0: \n      root.right = self.rightRotate(root.right) \n      return self.leftRotate(root) \n    return root \n  def leftRotate(self, z): \n    y = z.right \n    T2 = y.left \n    y.left = z \n    z.right = T2 \n    z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) \n    y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) \n    return y \n  def rightRotate(self, z): \n    y = z.left \n    T3 = y.right \n    y.right = z \n    z.left = T3 \n    z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) \n    y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) \n    return y \n  def getHeight(self, root): \n    if not root: \n      return 0\n    return root.height \n  def getBalance(self, root): \n    if not root: \n      return 0\n    return self.getHeight(root.left) - self.getHeight(root.right) \n  def getMinValueNode(self, root): \n    if root is None or root.left is None: \n      return root \n    return self.getMinValueNode(root.left) \n  def inOrder(self, root): \n    if not root: \n      return\n    self.inOrder(root.left) \n    C.append(int(\"{}\".format(root.val)))\n    self.inOrder(root.right) \n  def preOrder(self, root): \n    if not root: \n      return\n    print(\"{} \".format(root.val), end=\"\") \n    self.preOrder(root.left) \n    self.preOrder(root.right) \nmyTree = AVL_Tree() \nroot = None\nfor i in range(n+1):\n  root=myTree.insert(root,B[i])\nmyTree.inOrder(root)\na=1\nans=0\nfor i in range(1,n+1):\n  if C[i-1]==C[i]:\n    a=a+1\n    if i==n:\n      ans=ans+a*(a-1)//2\n  else:\n    ans=ans+a*(a-1)//2\n    a=1\nprint(ans)",
        "submission_id": "s487955378",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 124
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02900",
        "code_tokens": "import sys\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nimport math\nimport bisect\ninput = sys.stdin.readline\na, b = map(int, input().split())\nclass Mint(object):\n    def gcd(self, a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    def lcm(self, a, b):\n        return a * b // self.gcd(a, b)\n    @staticmethod\n    def cmb_(n, r):\n        from operator import mul\n        from functools import reduce\n        r = min(n - r, r)\n        if r == 0:\n            return 1\n        over = reduce(mul, range(n, n - r, -1))\n        under = reduce(mul, range(1, r + 1))\n        return over // under\n    def cmb(self, n, r, mod: int = 10 ** 9 + 7):\n        if (r < 0) or (r > n):\n            return 0\n        r = min(r, n - r)\n        return self.g1[n] * self.g2[r] * self.g2[n - r] % mod\n    def cmb_prep(self, N: int, mod: int = 10 ** 9 + 7):\n        self.g1 = [1, 1]  \n        self.g2 = [1, 1]  \n        inverse = [0, 1]  \n        for i in range(2, N + 1):\n            self.g1.append((self.g1[-1] * i) % mod)\n            inverse.append((-inverse[mod % i] * (mod // i)) % mod)\n            self.g2.append((self.g2[-1] * inverse[-1]) % mod)\n    @staticmethod\n    def iterated_power(z: int, n: int, mod=None) -> int:\n        beta = bin(n)[2:]\n        Z, q, t = z, 0, len(beta)\n        while beta[t - q - 1] == '0':\n            Z = Z * Z\n            if mod is not None:\n                Z = Z % mod\n            q += 1\n        result = Z\n        for k in range(q + 1, t):\n            Z = Z * Z\n            if mod is not None:\n                Z = Z % mod\n            if beta[t - k - 1] == '1':\n                result = result * Z\n                if mod is not None:\n                    result = result % mod\n        if mod is not None:\n            result = result % mod\n        return result\n    @staticmethod\n    def factorization(n: int) -> dict:\n        from collections import defaultdict\n        arr = defaultdict(int)\n        temp = n\n        for i in range(2, int(-(-n ** 0.5 // 1)) + 1):\n            if temp % i == 0:\n                cnt = 0\n                while temp % i == 0:\n                    cnt += 1\n                    temp //= i\n                arr[i] = cnt\n        if temp != 1:\n            arr[temp] = 1\n        if arr == []:\n            arr[n] = 1\n        return arr\n    @staticmethod\n    def enumerate_prime(n: int) -> (list, dict, list):\n        lis_prime = [True] * (n+1)\n        lis_prime[0] = False\n        lis_prime[1] = False\n        primes = []\n        div_prime = [i for i in range(n + 1)]\n        primes_idx = {}\n        cnt = 0\n        for i in range(2, n+1):\n            if lis_prime[i]:\n                primes.append(i)\n                primes_idx[i] = cnt\n                cnt += 1\n                j = 2 * i\n                while True:\n                    if j > n:\n                        break\n                    lis_prime[j] = False\n                    div_prime[j] = i\n                    j += i\n        return primes, primes_idx, div_prime\n    @staticmethod\n    def is_prime(n: int) -> bool:\n        if n == 1:\n            return False\n        if n == 2:\n            return True\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n            if i * i > n:\n                return True\n    @staticmethod\n    def divisor(n: int) -> list:\n        res = []\n        if n == 1:\n            return [1]\n        for i in range(1, n):\n            if n % i == 0:\n                res.append(i)\n                if i != n / i:\n                    res.append(int(n / i))\n            if (i+1) * (i+1) > n:\n                res.sort()\n                return res\nmint = Mint()\nc = mint.gcd(a, b)\ncandidates = mint.divisor(c)\nprimes, _, _ = mint.enumerate_prime(c)\nprint(len(set(candidates) & set(primes))+1)",
        "submission_id": "s796723501",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 126
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02866",
        "code_tokens": "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\nMOD = 10**9+7\nINF = float('inf')\nAtoZ = \"abcdefghijklmnopqrstuvwxyz\"\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\ndef DD(arg): return defaultdict(arg)\ndef inv(n): return pow(n, MOD-2, MOD)\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n):\n    return kaijo_memo[n]\n  if(len(kaijo_memo) == 0):\n    kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n):\n    kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n):\n    return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0):\n    gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n):\n    gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\ndef nCr(n,r):\n  if(n == r):\n    return 1\n  if(n < r or r < 0):\n    return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1:\n    arr.append([temp, 1])\n  if arr==[]:\n    arr.append([n, 1])\n  return arr\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  divisors.sort()\n  return divisors\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\ndef lcm(a, b):\n    return a * b // gcd (a, b)\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n -1\n    count += 1\n  return count\ndef base_10_to_n(X, n):\n  if X//n:\n    return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\nN = I()\nA = IL()\nM = max(A)\ndic = DD(int)\nfor a in A:\n  dic[a] += 1\nif dic[0] != 1:\n  print(-1)\nelse:\n  ans = 1\n  for i in range(M):\n    ans *= pow(dic[i],dic[i+1])\nprint(ans)",
        "submission_id": "s086508933",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 128
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02937",
        "code_tokens": "mod = 10 ** 9 + 7\nmod2 = 2**61+1\nfrom collections import deque\nimport heapq\nfrom bisect import bisect_left, insort_left\ndef iip(listed):\n    ret = [int(i) for i in input().split()]\n    if len(ret) == 1 and not listed:\n        return ret[0]\n    return ret\ndef main():\n    r = solve()\n    print(r)\ndef solve():\n    s = input()\n    s = [ord(i) - ord(\"a\") for i in s]\n    N = len(s)\n    t = input()\n    t = [ord(i) - ord(\"a\") for i in t]\n    posit = {}\n    for i in range(0, ord(\"z\")-ord(\"a\")+1):\n        posit[i] = []\n    for i, c in enumerate(s):\n        posit[c].append(i)\n    ans = 0\n    cur = -1\n    for src_target in t:\n        if not posit[src_target]:\n            return -1\n        if posit[src_target][-1] <= cur: \n            ans += (N-cur)\n            cur = 0\n        idx = bisect_left(posit[src_target], cur+1) \n        next = posit[src_target][idx]\n        ans += next - cur\n        cur = next\n    return ans\ndef split_print_space(s):\n    print(\" \".join([str(i) for i in s]))\ndef split_print_enter(s):\n    print(\"\\n\".join([str(i) for i in s]))\ndef koenai_saidai_x_index(sorted_list, n):\n    l = 0\n    r = len(sorted_list)\n    if len(sorted_list) == 0:\n        return False\n    if sorted_list[0] > n:\n        return False\n    while r - l > 1:\n        x = (l + r) // 2\n        if sorted_list[x] == n:\n            return x\n        elif sorted_list[x] > n:\n            r = x\n        else:\n            l = x\n    return l\ndef searchsorted(sorted_list, n, side):\n    if side not in [\"right\", \"left\"]:\n        raise Exception(\"side\u306fright\u304bleft\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\")\n    l = 0\n    r = len(sorted_list)\n    if n > sorted_list[-1]:\n        return len(sorted_list)\n    if n < sorted_list[0]:\n        return 0\n    while r - l > 1:\n        x = (l + r) // 2\n        if sorted_list[x] > n:\n            r = x\n        elif sorted_list[x] < n:\n            l = x\n        else:\n            if side == \"left\":\n                r = x\n            elif side == \"right\":\n                l = x\n    if side == \"left\":\n        if sorted_list[l] == n:\n            return r - 1\n        else:\n            return r\n    if side == \"right\":\n        if sorted_list[l] == n:\n            return l + 1\n        else:\n            return l\ndef soinsuu_bunkai(n):\n    ret = []\n    for i in range(2, int(n ** 0.5) + 1):\n        while n % i == 0:\n            n //= i\n            ret.append(i)\n        if i > n:\n            break\n    if n != 1:\n        ret.append(n)\n    return ret\ndef conbination(n, r, mod, test=False):\n    if n <= 0:\n        return 0\n    if r == 0:\n        return 1\n    if r < 0:\n        return 0\n    if r == 1:\n        return n\n    ret = 1\n    for i in range(n - r + 1, n + 1):\n        ret *= i\n        ret = ret % mod\n    bunbo = 1\n    for i in range(1, r + 1):\n        bunbo *= i\n        bunbo = bunbo % mod\n    ret = (ret * inv(bunbo, mod)) % mod\n    if test:\n        pass\n    return ret\ndef inv(n, mod):\n    return power(n, mod - 2)\ndef power(n, p, mod_= mod):\n    if p == 0:\n        return 1\n    if p % 2 == 0:\n        return (power(n, p // 2, mod_) ** 2) % mod_\n    if p % 2 == 1:\n        return (n * power(n, p - 1, mod_)) % mod_\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s097658190",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 130
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03014",
        "code_tokens": "H,W=map(int,input().split())\nS=[]\nfor h in range(H):\n    Sh=list(input())\n    newSh=[]\n    for w in range(W):\n        if Sh[w]=='\n            newSh.append(1)\n        else:\n            newSh.append(0)\n    Sh=newSh\n    S.append(Sh)\nL=[]\nfor h in range(H):\n    Lh=[]\n    a=0\n    for w in range(W):\n        if S[h][w]==0:\n            a+=1\n        else:\n            a=0\n        Lh.append(a)\n    L.append(Lh)\nR=[]\nfor h in range(H):\n    Rh=[]\n    a=0\n    for w in range(W):\n        if S[h][-(1+w)]==0:\n            a+=1\n        else:\n            a=0\n        Rh.append(a)\n    Rh.reverse()\n    R.append(Rh)\nU=[]\nfor w in range(W):\n    Uw=[]\n    a=0\n    for h in range(H):\n        if S[h][w]==0:\n            a+=1\n        else:\n            a=0\n        Uw.append(a)\n    U.append(Uw)\nU=[[U[w][h] for w in range(W)] for h in range(H)]\nD=[]\nfor w in range(W):\n    Dw=[]\n    a=0\n    for h in range(H):\n        if S[-(1+h)][w]==0:\n            a+=1\n        else:\n            a=0\n        Dw.append(a)\n    Dw.reverse()\n    D.append(Dw)\nD=[[D[w][h] for w in range(W)] for h in range(H)]\nmaxScore=0\nfor h in range(H):\n    for w in range(W):\n        score=L[h][w]+R[h][w]+U[h][w]+D[h][w]-3\n        if score>maxScore:\n            maxScore=score\nprint(maxScore)H,W=map(int,input().split())\nS=[]\nfor h in range(H):\n    Sh=list(input())\n    newSh=[]\n    for w in range(W):\n        if Sh[w]=='\n            newSh.append(1)\n        else:\n            newSh.append(0)\n    Sh=newSh\n    S.append(Sh)\nL=[]\nfor h in range(H):\n    Lh=[]\n    a=0\n    for w in range(W):\n        if S[h][w]==0:\n            a+=1\n        else:\n            a=0\n        Lh.append(a)\n    L.append(Lh)\nR=[]\nfor h in range(H):\n    Rh=[]\n    a=0\n    for w in range(W):\n        if S[h][-(1+w)]==0:\n            a+=1\n        else:\n            a=0\n        Rh.append(a)\n    Rh.reverse()\n    R.append(Rh)\nU=[]\nfor w in range(W):\n    Uw=[]\n    a=0\n    for h in range(H):\n        if S[h][w]==0:\n            a+=1\n        else:\n            a=0\n        Uw.append(a)\n    U.append(Uw)\nU=[[U[w][h] for w in range(W)] for h in range(H)]\nD=[]\nfor w in range(W):\n    Dw=[]\n    a=0\n    for h in range(H):\n        if S[-(1+h)][w]==0:\n            a+=1\n        else:\n            a=0\n        Dw.append(a)\n    Dw.reverse()\n    D.append(Dw)\nD=[[D[w][h] for w in range(W)] for h in range(H)]\nmaxScore=0\nfor h in range(H):\n    for w in range(W):\n        score=L[h][w]+R[h][w]+U[h][w]+D[h][w]-3\n        if score>maxScore:\n            maxScore=score\nprint(maxScore)",
        "submission_id": "s779381904",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 133
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03734",
        "code_tokens": "from heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom functools import *\nfrom itertools import permutations,combinations,groupby\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nimport random\ndef Golf():\n    *a,=map(int,open(0))\ndef S_():\n    return input()\ndef IS():\n    return input().split()\ndef LS():\n    return [i for i in input().split()]\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef NI(n):\n    return [int(input()) for i in range(n)]\ndef NI_(n):\n    return [int(input())-1 for i in range(n)]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef ItoS(nn):\n    return chr(nn+97)\ndef LtoS(ls):\n    return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'\n    mp=[1]*(w+2)\n    found={}\n    for i in range(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[1]+[mp_def[j] for j in s]+[1]\n    mp+=[1]*(w+2)\n    return h+2,w+2,mp,found\ndef bit_combination(k,n=2):\n    rt=[]\n    for tb in range(n**k):\n        s=[tb//(n**bt)%n for bt in range(k)]\n        rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['YES','NO']\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\nts=time.time()\ninput=lambda: sys.stdin.readline().rstrip()\ndef ran_input():\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\nshow_flg=False\nshow_flg=True\nans=0\nn,W=LI()\nm={}\nfor i in range(n):\n    w,v=LI()\n    if w in m:\n        m[w].append(v)\n    else:\n        m[w]=[v]\na=[]\nfor i,j in m.items():\n    sj=sorted(j)[::-1]\n    aj=[sum(j)]\n    for x in sj:\n        aj+=[aj[-1]-x]\n    a.append([i,len(j),aj])\ncnt0=[0]*len(m.items())\nweights=[i for i,j,k in a]\nans=0\nsys.setrecursionlimit(10**6)\nv=[False]*102**4\ndef dfs(cnt):\n    global ans\n    k=sum([cnt[i]*101**i for i in range(len(cnt))])\n    if v[k]:continue\n    v[k]= True\n    tot=0\n    V=0\n    for i in range(len(cnt)):\n        tot+=cnt[i]*weights[i]\n        if cnt[i]>a[i][1] or tot>W:\n            return\n        V+=a[i][2][0]-a[i][2][cnt[i]]\n    ans=max(ans,V)\n    for i in range(len(cnt)):\n        l=[cnt[j] + (1 if i==j else 0) for j in range(len(cnt))]\n        dfs(l)\ndfs(cnt0)\nprint(ans)",
        "submission_id": "s649753294",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 134
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02235",
        "code_tokens": "c = []\ndef prep_array(X, Y):\n    global c\n    c = [[0]*(len(X)+2) for _ in range(len(Y)+2)] \n    return c\ndef check_max(array):\n    max_lcs = 0\n    for row in array:\n        temp_max = max(row)\n        if temp_max > max_lcs:\n            max_lcs = temp_max\n    return max_lcs\ndef calc_lcs4(X, Y, c):\n    X = ' ' + X\n    Y = ' ' + Y\n    m = len(X)\n    n = len(Y)\n    max_lcs = 0\n    pre_row = c[0]\n    for i in range(1, m):\n        row = c[i]\n        XX = X[i]\n        for j, YY in enumerate(Y):\n            if XX == YY:\n                pr_j1 = pre_row[j - 1]\n                row[j] = pr_j1 + 1\n                if pr_j1+1 > max_lcs:\n                   max_lcs = pr_j1 + 1\n            else:\n                pr_j = pre_row[j]\n                r_j1 = row[j-1]\n                if pr_j >= r_j1:\n                    row[j] = pr_j\n                else:\n                    row[j] = r_j1\n        pre_row = row\n    return max_lcs\ndef calc_lcs3(X, Y, c):\n    m = len(X)\n    n = len(Y)\n    X = ' ' + X\n    Y = ' ' + Y\n    pre_row = c[0]\n    for i in range(1, m+1):\n        row = c[i]\n        XX = X[i]\n        for j in range(1, n+1):\n            if XX == Y[j]:\n                row[j] = pre_row[j - 1] + 1\n            elif pre_row[j] >= row[j - 1]:\n                row[j] = pre_row[j]\n            else:\n                row[j] = row[j - 1]\n        pre_row = row\n    return check_max(c)\ndef calc_lcs2(X, Y, c):\n    m = len(X)\n    n = len(Y)\n    X = ' ' + X\n    Y = ' ' + Y\n    pre_row = c[0]\n    for i in range(1, m+1):\n        row = c[i]\n        for j in range(1, n+1):\n            if X[i] == Y[j]:\n                row[j] = pre_row[j - 1] + 1\n            elif pre_row[j] >= row[j - 1]:\n                row[j] = pre_row[j]\n            else:\n                row[j] = row[j - 1]\n        pre_row = row\n    return check_max(c)\ndef calc_lcs1(X, Y):\n    from array import array\n    m = len(X)\n    n = len(Y)\n    X = ' ' + X\n    Y = ' ' + Y\n    c = array('i', [0] * (1024 * 1024))\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if X[i] == Y[j]:\n                c[i*1024 + j] = c[(i-1)*1024 + j - 1] + 1\n            elif c[(i-1)*1024 + j] >= c[i*1024 + j - 1]:\n                c[i*1024 + j] = c[(i-1)*1024 + j]\n            else:\n                c[i*1024 + j] = c[i*1024 + j - 1]\n    return max(c)\ndef calc_lcs1_1(X, Y):\n    from array import array\n    X = ' ' + X\n    Y = ' ' + Y\n    m = len(X)\n    n = len(Y)\n    max_lcs = 0\n    C = [array('I', [0] * n) for _ in range(m)]\n    pre_row = C[0]\n    for i in range(1, m):\n        row = C[i]\n        XX = X[i]\n        for j, YY in enumerate(Y[1:]):\n            if XX == YY:\n                pr_j1 = pre_row[j-1]\n                row[j] = pr_j1 + 1\n                if row[j] > max_lcs:\n                    max_lcs = pr_j1 + 1\n            else:\n                pr_j = pre_row[j]\n                r_j1 = row[j-1]\n                if pr_j >= r_j1:\n                    row[j] = pr_j\n                else:\n                    row[j]= r_j1\n        pre_row = row\n    return max_lcs\ndef calc_lcs(X, Y, c):\n    m = len(X)\n    n = len(Y)\n    X = ' ' + X\n    Y = ' ' + Y\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if X[i] == Y[j]:\n                c[i][j] = c[i - 1][j - 1] + 1\n            elif c[i - 1][j] >= c[i][j - 1]:\n                c[i][j] = c[i - 1][j]\n            else:\n                c[i][j] = c[i][j - 1]\n    return check_max(c)\nif __name__ == '__main__':\n    num = int(input())\n    for _ in range(num):\n        X = input().strip()\n        Y = input().strip()\n        result = calc_lcs4(X, Y, prep_array(X, Y))\n        print(result)",
        "submission_id": "s866563604",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 136
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02831",
        "code_tokens": "A, B = map(int, input().split())\nnumberA = 0\nnumberB = 0\ndataA = []\ndataB = []\nsosuA = []\nsosuB = []\nflagA = []\nflagB = []\ni = 1\nboc = 0\nwhile i <= A:\n    dataA += [i]\n    i += 1\ni = 1\nwhile i <= B:\n    dataB += [i]\n    i += 1\nn = 2\nwhile n <= A:\n    if A % n == 0:\n        sosuA += [n]\n        A = A / n\n        numberA += 1\n    else:\n        n += 1\nn = 2\nwhile n <= B:\n    if B % n == 0:\n        sosuB += [n]\n        B = B / n\n        numberB += 1\n    else:\n        n += 1\ni = 0\nn = 0\nrase = 0\nwhile i <= numberA - 1:\n    if i != 0 and sosuA[i] == sosuA[i - 1]:\n        kai = sosuA[i]\n        flagA += [kai]\n        i += 1\n        n = 0\n        continue\n    if sosuA[i] == sosuB[n]:\n        kai = sosuA[i]\n        flagA += [kai]\n        n += 1\n        rase = 1\n        boc = n\n        if i == numberA - 1:\n            break\n    elif rase == 1:\n        i += 1\n        n = 0\n        rase = 0\n    elif sosuA[i] != sosuB[n] and n == numberB - 1:\n        kai = sosuA[i]\n        flagA += [kai]\n        i += 1\n        n = 0\n    else:\n        n += 1\ni = 0\nn = 0\nwhile i <= numberB - 1:\n    if i != 0 and sosuB[i] == sosuB[i - 1]:\n        kai = sosuB[i]\n        flagB += [kai]\n        i += 1\n        n = 0\n        continue\n    if sosuB[i] == sosuA[n]:\n        kai = sosuB[i]\n        flagB += [kai]\n        n += 1\n        rase = 1\n        boc = n\n        if i == numberB - 1:\n            break\n    elif rase == 1:\n        i += 1\n        n = 0\n        rase = 0\n    elif sosuB[i] != sosuA[n] and n == numberA - 1:\n        kai = sosuB[i]\n        flagB += [kai]\n        i += 1\n        n = 0\n    else:\n        n += 1\ni = 0\nn = 0\ntuika = []\nif len(flagA) >= len(flagB):\n    while i <= numberB - 1:\n        if sosuB[i] == flagA[n]:\n            n += 1\n            i += 1\n        elif n == numberA - 1:\n            kai = sosuB[i]\n            tuika += [kai]\n            i += 1\n            n = 0\n        elif sosuB[i] < sosuA[n]:\n            kai = sosuB[i]\n            tuika += [kai]\n            n = 0\n            i += 1\n        else:\n            n += 1\n    flagA += tuika\n    ans = 1\n    for i in flagA:\n        ans = ans * i\n    print(ans)\nelse:\n    while i <= numberA - 1:\n        if sosuA[i] == flagB[n]:\n            n += 1\n            i += 1\n        elif n == numberB - 1:\n            kai = sosuA[i]\n            tuika += [kai]\n            i += 1\n            n = 0\n        elif sosuA[i] < sosuB[n]:\n            kai = sosuA[i]\n            tuika += [kai]\n            n = 0\n            i += 1\n        else:\n            n += 1\n    flagB += tuika\n    ans = 1\n    for i in flagB:\n        ans = ans * i\n    print(ans)",
        "submission_id": "s979879102",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 138
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03274",
        "code_tokens": "mod = 10 ** 9 + 7\nmod2 = 2**61+1\nfrom collections import deque\nimport heapq\nfrom bisect import bisect_left, insort_left, bisect_right\ndef iip(listed=True):\n    ret = [int(i) for i in input().split()]\n    if len(ret) == 1 and not listed:\n        return ret[0]\n    return ret\ndef iip_ord():\n    return [ord(i) - ord(\"a\") for i in input()]\ndef main():\n    ans = solve()\n    if ans is not None:\n        print(ans)\ndef solve():\n    N, K = iip(False)\n    X = iip()\n    A1 = [i for i in X if i >= 0]\n    A2 = [-i for i in X if i < 0]\n    A2.sort()\n    ans = 10**50\n    if len(A1) >= K:\n        ans = A1[K-1]\n    if len(A2) >= K:\n        ans = min(A2[K-1], ans)\n    for i in range(1, 10**10):\n        i1 = i-1\n        i2 = K-i-1\n        if i1 >= len(A1):\n            break\n        if i2 >= len(A2):\n            break\n        ans = min(2*A1[i1]+A2[i2], ans)\n        ans = min(2*A2[i2]+A1[i1], ans)\n    print(A1)\n    print(A2)\n    print(ans)\ndef YesNo(s):\n    if s:\n        print(\"Yes\")\n    else:\n        print(\"No\")\ndef fprint(s):\n    for i in s:\n        print(i)\ndef split_print_space(s):\n    print(\" \".join([str(i) for i in s]))\ndef split_print_enter(s):\n    print(\"\\n\".join([str(i) for i in s]))\ndef koenai_saidai_x_index(sorted_list, n):\n    l = 0\n    r = len(sorted_list)\n    if len(sorted_list) == 0:\n        return False\n    if sorted_list[0] > n:\n        return False\n    while r - l > 1:\n        x = (l + r) // 2\n        if sorted_list[x] == n:\n            return x\n        elif sorted_list[x] > n:\n            r = x\n        else:\n            l = x\n    return l\ndef searchsorted(sorted_list, n, side):\n    if side not in [\"right\", \"left\"]:\n        raise Exception(\"side\u306fright\u304bleft\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\")\n    l = 0\n    r = len(sorted_list)\n    if n > sorted_list[-1]:\n        return len(sorted_list)\n    if n < sorted_list[0]:\n        return 0\n    while r - l > 1:\n        x = (l + r) // 2\n        if sorted_list[x] > n:\n            r = x\n        elif sorted_list[x] < n:\n            l = x\n        else:\n            if side == \"left\":\n                r = x\n            elif side == \"right\":\n                l = x\n    if side == \"left\":\n        if sorted_list[l] == n:\n            return r - 1\n        else:\n            return r\n    if side == \"right\":\n        if sorted_list[l] == n:\n            return l + 1\n        else:\n            return l\ndef soinsuu_bunkai(n):\n    ret = []\n    for i in range(2, int(n ** 0.5) + 1):\n        while n % i == 0:\n            n //= i\n            ret.append(i)\n        if i > n:\n            break\n    if n != 1:\n        ret.append(n)\n    return ret\ndef conbination(n, r, mod, test=False):\n    if n <= 0:\n        return 0\n    if r == 0:\n        return 1\n    if r < 0:\n        return 0\n    if r == 1:\n        return n\n    ret = 1\n    for i in range(n - r + 1, n + 1):\n        ret *= i\n        ret = ret % mod\n    bunbo = 1\n    for i in range(1, r + 1):\n        bunbo *= i\n        bunbo = bunbo % mod\n    ret = (ret * inv(bunbo, mod)) % mod\n    if test:\n        pass\n    return ret\ndef inv(n, mod):\n    return power(n, mod - 2)\ndef power(n, p, mod_= mod):\n    if p == 0:\n        return 1\n    if p % 2 == 0:\n        return (power(n, p // 2, mod_) ** 2) % mod_\n    if p % 2 == 1:\n        return (n * power(n, p - 1, mod_)) % mod_\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s064806068",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 140
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02974",
        "code_tokens": "def main():\n    import sys\n    sys.setrecursionlimit(10**7)\n    from itertools import accumulate, combinations, permutations, product \n    from math import factorial, ceil, floor, sqrt\n    def factorize(n):\n        fct = []  \n        b, e = 2, 0  \n        while b * b <= n:\n            while n % b == 0:\n                n = n // b\n                e = e + 1\n            if e > 0:\n                fct.append((b, e))\n            b, e = b + 1, 0\n        if n > 1:\n            fct.append((n, 1))\n        return fct\n    def combinations_count(n, r):\n        if n < 0 or r < 0:\n            raise Exception('combinations_count(n, r) not defined when n or r is negative')\n        if n - r < r: r = n - r\n        if r < 0: return 0\n        if r == 0: return 1\n        if r == 1: return n\n        numerator = [n - r + k + 1 for k in range(r)]\n        denominator = [k + 1 for k in range(r)]\n        for p in range(2,r+1):\n            pivot = denominator[p - 1]\n            if pivot > 1:\n                offset = (n - r) % p\n                for k in range(p-1,r,p):\n                    numerator[k - offset] /= pivot\n                    denominator[k] /= pivot\n        result = 1\n        for k in range(r):\n            if numerator[k] > 1:\n                result *= int(numerator[k])\n        return result\n    def combinations_with_replacement_count(n, r):\n        if n < 0 or r < 0:\n            raise Exception('combinations_with_replacement_count(n, r) not defined when n or r is negative')\n        elif n == 0:\n            return 1\n        else:\n            return combinations_count(n + r - 1, r)\n    from bisect import bisect_left, bisect_right\n    from collections import deque, Counter, defaultdict \n    from heapq import heapify, heappop, heappush, heappushpop, heapreplace,nlargest,nsmallest \n    from copy import deepcopy, copy \n    import operator\n    from operator import itemgetter\n    from functools import reduce, lru_cache\n    def chmin(x, y):\n        if x > y:\n            x = y\n            return (x, True)\n        else:\n            return (x, False)\n    def chmax(x, y):\n        if x < y:\n            x = y\n            return (x, True)\n        else:\n            return (x, False)\n    from fractions import gcd \n    def gcds(numbers):\n        return reduce(gcd, numbers)\n    def lcm(x, y):\n        return (x * y) // gcd(x, y)\n    def lcms(numbers):\n        return reduce(lcm, numbers, 1)\n    INF = 10 ** 18\n    MOD = 10 ** 9 + 7\n    modpow = lambda a, n, p = MOD: pow(a, n, p) \n    def modinv(a, p = MOD):\n        return modpow(a, p-2, p)\n    def modinv_list(n, p = MOD):\n        if n <= 1:\n            return [0,1][:n+1]\n        else:\n            inv_t = [0,1]\n            for i in range(2, n+1):\n                inv_t += [inv_t[p % i] * (p - int(p / i)) % p]\n            return inv_t\n    def modfactorial_list(n, p = MOD):\n        if n == 0:\n            return [1]\n        else:\n            l = [0] * (n+1)\n            tmp = 1\n            for i in range(1, n+1):\n                tmp = tmp * i % p\n                l[i] = tmp\n            return l\n    def modcomb(n, k, fac_list = [], p = MOD):\n        from math import factorial\n        if n < 0 or k < 0 or n < k: return 0\n        if n == 0 or k == 0: return 1\n        if len(fac_list) <= n:\n            a = factorial(n) % p\n            b = factorial(k) % p\n            c = factorial(n-k) % p\n        else:\n            a = fac_list[n]\n            b = fac_list[k]\n            c = fac_list[n-k]\n        return (a * modpow(b, p-2, p) * modpow(c, p-2, p)) % p\n    def modadd(a, b, p = MOD):\n        return (a + b) % MOD\n    def modsub(a, b, p = MOD):\n        return (a - b) % p\n    def modmul(a, b, p = MOD):\n        return ((a % p) * (b % p)) % p\n    def moddiv(a, b, p = MOD):\n        return modmul(a, modpow(b, p-2, p))\n    r = lambda: sys.stdin.readline().strip()\n    r_int = lambda: int(r())\n    R = lambda: list(map(int, r().split()))\n    Rmap = lambda: map(int, r().split())\n    Rfloat = lambda: list(map(float, r().split()))\n    Rtuple = lambda: tuple(map(int, r().split()))\n    if __name__ != '__main__':\n        sys.stdin = open('sample.txt')\n    N, K = R()\n    dp = [0]*2600*51*51\n    ip = 2600*51\n    restp = 2600\n    dp[0] = 1\n    for i, rest, k in product(range(N), range(N), range(0,K+1,2)):\n        dp[(i+1)*ip+(rest+1)*restp+(k+2*rest+2)] += dp[i*ip+rest*restp+k]\n        dp[(i+1)*ip+(rest+1)*restp+(k+2*rest+2)] %= MOD\n        dp[(i+1)*ip+rest*restp+(k+2*rest)] += dp[i*ip+rest*restp+k] * (2*rest+1)\n        dp[(i+1)*ip+rest*restp+(k+2*rest)] %= MOD\n        if rest:\n            dp[(i+1)*ip+(rest-1)*restp+(k+2*rest-2)] += dp[i*ip+rest*restp+k] * rest * rest\n            dp[(i+1)*ip+(rest-1)*restp+(k+2*rest-2)] %= MOD\n    print(dp[N*ip+K])\nif __name__ == '__main__':\n    main()",
        "submission_id": "s543790813",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 140
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02763",
        "code_tokens": "mod = 10 ** 9 + 7\nmod2 = 2**61+1\nfrom collections import deque\nimport heapq\nfrom bisect import bisect_left, insort_left\ndef iip(listed):\n    ret = [int(i) for i in input().split()]\n    if len(ret) == 1 and not listed:\n        return ret[0]\n    return ret\ndef main():\n    r = solve()\ndef solve():\n    K = iip(False)\n    S = input()\n    S = [ord(i) for i in S]\n    Q = iip(False)\n    posit = {}\n    for i in range(ord(\"a\"), ord(\"z\")+1):\n        posit[i] = []\n    query = []\n    for i in range(Q):\n        query.append(input().split())\n    for i, j in enumerate(S, 1):\n        posit[j].append(i)\n    result = []\n    for q in query:\n        if q[0] == \"1\":\n            p = int(q[1])\n            before = S[p-1]\n            after = ord(q[2])\n            if before == after:\n                continue\n            S[p-1] = after\n            idx = bisect_left(posit[before], p)\n            posit[before].pop(idx)\n            insort_left(posit[after], p)\n        else:\n            l = int(q[1])\n            r = int(q[2])\n            ret = 0\n            for i in range(ord(\"a\"), ord(\"z\")+1):\n                ll = bisect_left(l)\n                rr = bisect_left(rr)\n                if ll != rr:\n                    ret += 1\n            result.append(ret)\n    split_print_space(result)\n    return\ndef split_print_space(s):\n    print(\" \".join([str(i) for i in s]))\ndef split_print_enter(s):\n    print(\"\\n\".join([str(i) for i in s]))\ndef koenai_saidai_x_index(sorted_list, n):\n    l = 0\n    r = len(sorted_list)\n    if len(sorted_list) == 0:\n        return False\n    if sorted_list[0] > n:\n        return False\n    while r - l > 1:\n        x = (l + r) // 2\n        if sorted_list[x] == n:\n            return x\n        elif sorted_list[x] > n:\n            r = x\n        else:\n            l = x\n    return l\ndef searchsorted(sorted_list, n, side):\n    if side not in [\"right\", \"left\"]:\n        raise Exception(\"side\u306fright\u304bleft\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\")\n    l = 0\n    r = len(sorted_list)\n    if n > sorted_list[-1]:\n        return len(sorted_list)\n    if n < sorted_list[0]:\n        return 0\n    while r - l > 1:\n        x = (l + r) // 2\n        if sorted_list[x] > n:\n            r = x\n        elif sorted_list[x] < n:\n            l = x\n        else:\n            if side == \"left\":\n                r = x\n            elif side == \"right\":\n                l = x\n    if side == \"left\":\n        if sorted_list[l] == n:\n            return r - 1\n        else:\n            return r\n    if side == \"right\":\n        if sorted_list[l] == n:\n            return l + 1\n        else:\n            return l\ndef soinsuu_bunkai(n):\n    ret = []\n    for i in range(2, int(n ** 0.5) + 1):\n        while n % i == 0:\n            n //= i\n            ret.append(i)\n        if i > n:\n            break\n    if n != 1:\n        ret.append(n)\n    return ret\ndef conbination(n, r, mod, test=False):\n    if n <= 0:\n        return 0\n    if r == 0:\n        return 1\n    if r < 0:\n        return 0\n    if r == 1:\n        return n\n    ret = 1\n    for i in range(n - r + 1, n + 1):\n        ret *= i\n        ret = ret % mod\n    bunbo = 1\n    for i in range(1, r + 1):\n        bunbo *= i\n        bunbo = bunbo % mod\n    ret = (ret * inv(bunbo, mod)) % mod\n    if test:\n        pass\n    return ret\ndef inv(n, mod):\n    return power(n, mod - 2)\ndef power(n, p, mod_= mod):\n    if p == 0:\n        return 1\n    if p % 2 == 0:\n        return (power(n, p // 2, mod_) ** 2) % mod_\n    if p % 2 == 1:\n        return (n * power(n, p - 1, mod_)) % mod_\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s637282703",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 142
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03745",
        "code_tokens": "import math\nimport queue\nfrom collections import defaultdict\ndef readInt():\n\treturn int(input())\ndef readInts():\n\treturn list(map(int, input().split()))\ndef readChar():\n\treturn input()\ndef readChars():\n\treturn input().split()\ndef factorization(n):\n\tres = []\n\tif n%2==0:\n\t\tres.append(2)\n\tfor i in range(3,math.floor(n//2)+1,2):\n\t\tif n%i==0:\n\t\t\tc = 0\n\t\t\tfor j in res:\n\t\t\t\tif i%j==0:\n\t\t\t\t\tc=1\n\t\t\tif c==0:\n\t\t\t\tres.append(i)\n\treturn res\ndef fact2(n):\n\tp = factorization(n)\n\tres = []\n\tfor i in p:\n\t\tc=0\n\t\tz=n\n\t\twhile 1:\n\t\t\tif z%i==0:\n\t\t\t\tc+=1\n\t\t\t\tz/=i\n\t\t\telse:\n\t\t\t\tbreak\n\t\tres.append([i,c])\n\treturn res\ndef fact(n):\n\tans = 1\n\tm=n\n\tfor _i in range(n-1):\n\t\tans*=m\n\t\tm-=1\n\treturn ans\ndef comb(n,r):\n\tif n<r:\n\t\treturn 0\n\tl = min(r,n-r)\n\tm=n\n\tu=1\n\tfor _i in range(l):\n\t\tu*=m\n\t\tm-=1\n\treturn u//fact(l)\ndef printQueue(q):\n\tr=qb\n\tans=[0]*r.qsize()\n\tfor i in range(r.qsize()-1,-1,-1):\n\t\tans[i] = r.get()\n\tprint(ans)\ndef dq():\n\treturn queue.deque()\nclass UnionFind():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.parents = [-1]*n\n\tdef find(self, x): \n\t\tif self.parents[x]<0:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.parents[x] = self.find(self.parents[x])\n\t\t\treturn self.parents[x]\n\tdef union(self,x,y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\t\tif x==y:\n\t\t\treturn\n\t\tif self.parents[x]>self.parents[y]:\n\t\t\tx,y = y,x\n\t\tself.parents[x]+=self.parents[y]\n\t\tself.parents[y]=x\n\tdef size(self,x):\n\t\treturn -1*self.parents[self.find(x)]\n\tdef same(self,x,y):\n\t\treturn self.find(x)==self.find(y)\n\tdef members(self,x): \n\t\troot = self.find(x)\n\t\treturn [i for i in range(self.n) if self.find(i)==root]\n\tdef roots(self):\n\t\treturn [i for i,x in enumerate(self.parents) if x<0]\n\tdef group_count(self):\n\t\treturn len(self.roots())\n\tdef all_group_members(self):\n\t\treturn {r: self.members(r) for r in self.roots()} \ndef bitArr(n):\n\tx = 1\n\tzero = \"0\"*n\n\tans = []\n\tans.append([0]*n)\n\tfor i in range(2**n-1):\n\t\tans.append(list(map(lambda x:int(x),list((zero+bin(x)[2:])[-1*n:]))))\n\t\tx+=1\n\treturn ans;\ndef arrsSum(a1,a2):\n\tfor i in range(len(a1)):\n\t\ta1[i]+=a2[i]\n\treturn a1\ndef maxValue(a,b,v):\n\tv2 = v\n\tfor i in range(v2,-1,-1):\n\t\tfor j in range(v2//a+1): \n\t\t\tk = i-a*j\n\t\t\tif k%b==0:\n\t\t\t\treturn i\n\treturn -1\nn = readInt()\na = readInts()\nans = 1\ni = 0\ndef plumin(i):\n\tif a[i+1]-a[i]>0:\n\t\treturn 1\n\telif a[i+1]-a[i]<0:\n\t\treturn -1\n\telse:\n\t\treturn 0\npmarr = []\nb= 0\nfor i in range(n-1):\n\tpmarr.append(plumin(i))\nwhile 0 in pmarr:\n\tpmarr.remove(0)\nbe = pmarr[0]\nfor i in range(1,len(pmarr)):\n\tif pmarr[i]==be:\n\t\tcontinue\n\telse:\n\t\tans+=1\n\t\tif i+1==len(pmarr):\n\t\t\tbreak\n\t\tbe = pmarr[i+1]\nprint(ans)",
        "submission_id": "s977337268",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 143
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02575",
        "code_tokens": "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\nMOD = 10**9+7\nINF = float('inf')\nAZ = \"abcdefghijklmnopqrstuvwxyz\"\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\ndef DD(arg): return defaultdict(arg)\ndef inv(n): return pow(n, MOD-2, MOD)\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1: arr.append([temp, 1])\n  if arr==[]: arr.append([n, 1])\n  return arr\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  return divisors\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return a\ndef lcm(a, b):\n    return a * b // gcd (a, b)\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n-1\n    count += 1\n  return count\ndef base_10_to_n(X, n):\n  if X//n: return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\ndef base_10_to_n_without_0(X, n):\n  X -= 1\n  if X//n: return base_10_to_n_without_0(X//n, n)+[X%n]\n  return [X%n]\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\nH,W = IL()\ndata = ILL(H)\ndic = DD(int)\nfor i in range(W):\n  dic[i] = i\nmembers = DD(int)\nfor i in range(W):\n  members[i] = 1\nprev_valid = [i-1 for i in range(W)]\ndef calc_prev_valid(x):\n  if prev_valid[x] == -1: return -1\n  if not members[prev_valid[x]]:\n    prev_valid[x] = calc_prev_valid(prev_valid[x])\n  return prev_valid[x]\ncount_score = DD(int)\ncount_score[0] = W\nscore = 0\nfor i in range(H):\n  a,b = data[i]\n  a -= 1\n  b -= 1\n  now = b\n  while now >= a:\n    if members[now]:\n      count_score[now-dic[now]] -= members[now]\n      if not members[b+1]:\n        dic[b+1] = dic[now]\n      if b+1 < W:\n        count_score[(b+1)-dic[b+1]] += members[now]\n      members[b+1] += members[now]\n      members[now] = 0\n    now = calc_prev_valid(now)\n    if now == -1:\n      break\n  while True:\n    if count_score[score]:\n      print(score+i+1)\n      break\n    else:\n      score += 1\n    if score == W:\n      for j in range(H-i):\n        print(-1)\n      exit()",
        "submission_id": "s622250242",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 143
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02605",
        "code_tokens": "def main():\n    n = int(input())\n    xyp = [input().split() for _ in [0]*n]\n    for i in range(n):\n        xyp[i][0] = int(xyp[i][0])\n        xyp[i][1] = int(xyp[i][1])\n    inf = 10**10\n    ans = inf\n    u_list = []\n    d_list = []\n    for i in range(n):\n        if xyp[i][2] == \"U\":\n            u_list.append((xyp[i][0], xyp[i][1]))\n        if xyp[i][2] == \"D\":\n            d_list.append((xyp[i][0], xyp[i][1]))\n    li, lj = len(u_list), len(d_list)\n    u_list.sort()\n    d_list.sort()\n    i, j = 0, 0\n    while(i < li and j < lj):\n        if u_list[i][0] < d_list[j][0]:\n            i += 1\n        elif u_list[i][0] > d_list[j][0]:\n            j += 1\n        else:\n            if u_list[i][1] < d_list[j][1]:\n                ans = min(ans, (d_list[j][1] - u_list[i][1])*5)\n                i += 1\n            else:\n                j += 1\n    r_list = []\n    l_list = []\n    for i in range(n):\n        if xyp[i][2] == \"R\":\n            r_list.append((xyp[i][0], xyp[i][1]))\n        if xyp[i][2] == \"L\":\n            l_list.append((xyp[i][0], xyp[i][1]))\n    li, lj = len(r_list), len(l_list)\n    r_list.sort()\n    l_list.sort()\n    i, j = 0, 0\n    while(i < li and j < lj):\n        if r_list[i][1] < l_list[j][1]:\n            i += 1\n        elif r_list[i][1] > l_list[j][1]:\n            j += 1\n        else:\n            if r_list[i][0] < l_list[j][0]:\n                ans = min(ans, (l_list[j][0] - r_list[i][0])*5)\n                i += 1\n            else:\n                j += 1\n    u_list = []\n    l_list = []\n    for i in range(n):\n        if xyp[i][2] == \"U\":\n            u_list.append((xyp[i][0], xyp[i][1]))\n        if xyp[i][2] == \"L\":\n            l_list.append((xyp[i][0], xyp[i][1]))\n    li, lj = len(u_list), len(l_list)\n    u_list.sort(key=lambda x: x[0]-x[1])\n    l_list.sort(key=lambda x: x[0]-x[1])\n    i, j = 0, 0\n    while(i < li and j < lj):\n        if u_list[i][0]-u_list[i][1] < l_list[j][0]-l_list[j][1]:\n            i += 1\n        elif u_list[i][0]-u_list[i][1] > l_list[j][0]-l_list[j][1]:\n            j += 1\n        else:\n            if u_list[i][0] < l_list[j][0]:\n                ans = min(ans, (l_list[j][0] - u_list[i][0])*10)\n                i += 1\n            else:\n                j += 1\n    d_list = []\n    l_list = []\n    for i in range(n):\n        if xyp[i][2] == \"D\":\n            d_list.append((xyp[i][0], xyp[i][1]))\n        if xyp[i][2] == \"L\":\n            l_list.append((xyp[i][0], xyp[i][1]))\n    li, lj = len(d_list), len(l_list)\n    d_list.sort(key=lambda x: x[0]+x[1])\n    l_list.sort(key=lambda x: x[0]+x[1])\n    i, j = 0, 0\n    while(i < li and j < lj):\n        if d_list[i][0]+d_list[i][1] < l_list[j][0]+l_list[j][1]:\n            i += 1\n        elif d_list[i][0]+d_list[i][1] > l_list[j][0]+l_list[j][1]:\n            j += 1\n        else:\n            if d_list[i][0] < l_list[j][0]:\n                ans = min(ans, (l_list[j][0] - d_list[i][0])*10)\n                i += 1\n            else:\n                j += 1\n    u_list = []\n    r_list = []\n    for i in range(n):\n        if xyp[i][2] == \"U\":\n            u_list.append((xyp[i][0], xyp[i][1]))\n        if xyp[i][2] == \"R\":\n            r_list.append((xyp[i][0], xyp[i][1]))\n    li, lj = len(u_list), len(r_list)\n    u_list.sort(key=lambda x: (x[0]+x[1], -x[0]))\n    r_list.sort(key=lambda x: (x[0]+x[1], -x[0]))\n    i, j = 0, 0\n    while(i < li and j < lj):\n        if u_list[i][0]+u_list[i][1] < r_list[j][0]+r_list[j][1]:\n            i += 1\n        elif u_list[i][0]+u_list[i][1] > r_list[j][0]+r_list[j][1]:\n            j += 1\n        else:\n            if u_list[i][0] > r_list[j][0]:\n                ans = min(ans, (u_list[j][0] - r_list[i][0])*10)\n                i += 1\n            else:\n                j += 1\n    d_list = []\n    r_list = []\n    for i in range(n):\n        if xyp[i][2] == \"D\":\n            d_list.append((xyp[i][0], xyp[i][1]))\n        if xyp[i][2] == \"R\":\n            r_list.append((xyp[i][0], xyp[i][1]))\n    li, lj = len(d_list), len(r_list)\n    d_list.sort(key=lambda x: (x[0]-x[1], -x[0]))\n    r_list.sort(key=lambda x: (x[0]-x[1], -x[0]))\n    i, j = 0, 0\n    while(i < li and j < lj):\n        if d_list[i][0]-d_list[i][1] < r_list[j][0]-r_list[j][1]:\n            i += 1\n        elif d_list[i][0]-d_list[i][1] > r_list[j][0]-r_list[j][1]:\n            j += 1\n        else:\n            if d_list[i][0] > r_list[j][0]:\n                ans = min(ans, (d_list[j][0] - r_list[i][0])*10)\n                i += 1\n            else:\n                j += 1\n    if ans == inf:\n        print(\"SAFE\")\n    else:\n        print(ans)\nmain()",
        "submission_id": "s268410655",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 145
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02836",
        "code_tokens": "{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 14,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"13 7 2\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"all = input()\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 15,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"all = input()\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 16,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"['13', '7', '2']\"\n      ]\n     },\n     \"execution_count\": 16,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"all\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 17,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"all = [int(num) for num in all]\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 18,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"[13, 7, 2]\"\n      ]\n     },\n     \"execution_count\": 18,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"all\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 19,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"ename\": \"AttributeError\",\n     \"evalue\": \"'list' object has no attribute 'sum'\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"\\u001b[0;31m---------------------------------------------------------------------------\\u001b[0m\",\n      \"\\u001b[0;31mAttributeError\\u001b[0m                            Traceback (most recent call last)\",\n      \"\\u001b[0;32m<ipython-input-19-1727d8e1239d>\\u001b[0m in \\u001b[0;36m<module>\\u001b[0;34m\\u001b[0m\\n\\u001b[0;32m----> 1\\u001b[0;31m \\u001b[0mall\\u001b[0m\\u001b[0;34m.\\u001b[0m\\u001b[0msum\\u001b[0m\\u001b[0;34m\\u001b[0m\\u001b[0;34m\\u001b[0m\\u001b[0m\\n\\u001b[0m\",\n      \"\\u001b[0;31mAttributeError\\u001b[0m: 'list' object has no attribute 'sum'\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"all.sum\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 20,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"bust\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"if sum(all) >= 22:\\n\",\n    \"    print('bust')\\n\",\n    \"else:\\n\",\n    \"    print('win')\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.7.3\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 2\n}",
        "submission_id": "s761287503",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 148
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02541",
        "code_tokens": "import sys\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c for j in range(b)] for i in range(a)]\ndef list3d(a, b, c, d): return [[[d for k in range(c)] for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e for l in range(d)] for k in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10**9)\nINF = 10**19\nMOD = 10**9 + 7\nEPS = 10**-10\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        n += 1\n        nv = 1\n        while nv < n:\n            nv *= 2\n        self.size = nv\n        self.tree = [0] * nv\n    def sum(self, i):\n        s = 0\n        i += 1\n        while i > 0:\n            s += self.tree[i-1]\n            i -= i & -i\n        return s\n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i-1] += x\n            i += i & -i\n    def query(self, l, r):\n        return self.sum(r-1) - self.sum(l-1)\n    def get(self, i):\n        return self.query(i, i+1)\n    def update(self, i, x):\n        self.add(i, x - self.get(i))\n    def print(self):\n        for i in range(self.n):\n            print(self.get(i), end=' ')\n        print()\n    def bisearch_fore(self, l, r, x):\n        l_sm = self.sum(l-1)\n        ok = r + 1\n        ng = l - 1\n        while ng+1 < ok:\n            mid = (ok+ng) // 2\n            if self.sum(mid) - l_sm >= x:\n                ok = mid\n            else:\n                ng = mid\n        if ok != r + 1:\n            return ok\n        else:\n            return INF\n    def bisearch_back(self, l, r, x):\n        r_sm = self.sum(r)\n        ok = l - 1\n        ng = r + 1\n        while ok+1 < ng:\n            mid = (ok+ng) // 2\n            if r_sm - self.sum(mid-1) >= x:\n                ok = mid\n            else:\n                ng = mid\n        if ok != l - 1:\n            return ok\n        else:\n            return -INF\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n        self.tree = [True] * n\n        self.grpcnt = n\n    def find(self, x):\n        t = []\n        while self.par[x] != x:\n            t.append(x)\n            x = self.par[x]\n        for i in t:\n            self.par[i] = x\n        return self.par[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            self.tree[x] = False\n            return\n        if not self.tree[x] or not self.tree[y]:\n            self.tree[x] = self.tree[y] = False\n        self.grpcnt -= 1\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    def get_size(self, x=None):\n        if x is not None:\n            return self.size[self.find(x)]\n        else:\n            return self.grpcnt\n    def is_tree(self, x):\n        return self.tree[self.find(x)]\nN = INT()\nXY = []\nXtoY = [0] * (N+1)\nYtoI = [0] * (N+1)\nfor i in range(N):\n    x, y = MAP()\n    XY.append((x, y))\n    XtoY[x] = (y, i)\n    YtoI[y] = i\nbit = BIT(N+1)\nuf = UnionFind(N)\nfor i in range(1, N+1):\n    bit.add(i, 1)\nfor x in range(1, N+1):\n    y, i = XtoY[x]\n    cury = y\n    while 1:\n        nxty = bit.bisearch_fore(cury+1, N, 1)\n        if nxty == INF:\n            break\n        else:\n            j = YtoI[nxty]\n            if uf.is_same(i, j):\n                break\n            else:\n                uf.union(i, j)\n                cury = nxty\n    bit.add(y, -1)\nfor i in range(N):\n    ans = uf.get_size(i)\n    print(ans)",
        "submission_id": "s233869141",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "line_of_code": 149
    }
]
